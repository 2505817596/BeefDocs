[
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/",
	"title": "发布说明",
	"tags": [],
	"description": "",
	"content": "2025 年 3 月 19 日\nVersion 0.43.5\n2022 年 9 月 7 日\nVersion 0.43.4\n2022 年 6 月 20 日\nVersion 0.43.3\n2022 年 3 月 29 日\nVersion 0.43.2\n2021 年 11 月 22 日\nVersion 0.43.1\n2021 年 2 月 22 日\nVersion 0.43.0\n2020 年 12 月 9 日\nVersion 0.42.8\n2020 年 10 月 5 日\nVersion 0.42.7\n2020 年 9 月 9 日\nVersion 0.42.6\n2020 年 6 月 25 日\nVersion 0.42.5\n2020 年 5 月 20 日\nVersion 0.42.4\n2020 年 4 月 30 日\nVersion 0.42.3\n2020 年 4 月 7 日\nVersion 0.42.2\n公开发布\n2019 年 12 月 31 日\nVersion 0.42.1\n初始发布\n2019 年 9 月 29 日\nVersion 0.42.0\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/getting-start/installation/",
	"title": "安装",
	"tags": [],
	"description": "",
	"content": " 稳定版 版本：0.43.5 发布日期：2025 年 3 月 19 日\nWindows 64 位：下载\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_0/",
	"title": "版本 0.42.0",
	"tags": [],
	"description": "",
	"content": "2019 年 9 月 29 日\n初始发布\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_1/",
	"title": "版本 0.42.1",
	"tags": [],
	"description": "",
	"content": "2019 年 12 月 31 日\n首次公开发布\n 改进交叉编译能力 新增 macOS、iOS 与 Android 构建目标 调试分配器 GC 优化 新增运算符约束支持 新增分配对齐覆盖特性 扩展 lambda 捕获列表以支持指定变量名 改进可空类型能力（包含运算符）  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_2/",
	"title": "版本 0.42.2",
	"tags": [],
	"description": "",
	"content": "2020 年 4 月 7 日\n 错误面板，左下角错误图标 修复带载荷枚举的数据循环崩溃 修复项目名与目录不匹配时的创建问题 修复空项目使用 \u0026ldquo;-run\u0026rdquo; 时崩溃 BeefBuild 新增 \u0026ldquo;-generate\u0026rdquo; 选项 新增复合赋值运算符重载（如 +=） 支持 C 风格可变参数 修复函数内联 新增未初始化构造函数支持（this(?), base(?)） 移除 \u0026lsquo;internal\u0026rsquo; 访问级别 新增 Quick Info 快捷键 新增源码 MD5 哈希 Ctrl+单击跳转到定义  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_3/",
	"title": "版本 0.42.3",
	"tags": [],
	"description": "",
	"content": "2020 年 4 月 30 日\n 修复安装程序崩溃 修复从工作区移除项目时崩溃 修复在非英文系统上打开示例的问题 其他多项修复 新增空条件运算符重载 - 在 Result 中实现 将 System.Collections.Generic 重命名为 System.Collections 新增 ICollection  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_4/",
	"title": "版本 0.42.4",
	"tags": [],
	"description": "",
	"content": "2020 年 5 月 20 日\n 重构 ref 枚举器，支持 Dictionary Key/Value 的 ref 枚举 调试模式下，离开作用域的原始 scope 分配会标记为已删除 扩展表达式主体支持 移除 Func/Action 反射增强 新增编辑器设置：Free Cursor Movement 改进多显示器支持 扩展反射支持 三击选择整行 更多代码悬停提示  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_5/",
	"title": "版本 0.42.5",
	"tags": [],
	"description": "",
	"content": "2020 年 6 月 25 日\n 反射扩展了自定义特性支持 支持接口扩展 反射包含类型与方法的自定义特性 支持重命名标签与命名空间 \u0026lsquo;using static\u0026rsquo; 扩展方法 新增选项：关闭 Ctrl+Arrow 自动补全 提升超大方法的后端速度 定长数组大小推断支持 \u0026lsquo;?\u0026rsquo; 改进全局静态定长数组初始化 编辑器支持更多按键组合 鼠标悬停属性求值 新增严格相等运算符 === 与 !== 新增初始化表达式  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_6/",
	"title": "版本 0.42.6",
	"tags": [],
	"description": "",
	"content": "2020 年 9 月 9 日\n SIMD 库起步 alloctype(T) 将方法可变性纳入签名与方法选择 支持非静态 ++ 和 -- 运算符重载 out 参数丢弃 ? ??= 运算符 IDE 新增诊断面板 Distinct Build Options 新增反射设置 IDE 主题支持 Ctrl+Tab 最近文件列表 IDE 支持移动行/语句  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_7/",
	"title": "版本 0.42.7",
	"tags": [],
	"description": "",
	"content": "2020 年 10 月 5 日\n 来自 System.Variant 的动态装箱 decltype(val).MemberName 表达式 out 变量声明的作用域向外移动 改进未赋值变量检测 新增显式 \u0026ldquo;Test\u0026rdquo; 项目类型 反射接口方法派发 Distinct Build Options 的接口过滤 IDE 在崩溃/断电后可恢复文件 更好地处理源码中的合并冲突标记  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_42_8/",
	"title": "版本 0.42.8",
	"tags": [],
	"description": "",
	"content": "2020 年 12 月 9 日\n LLVM 更新至 11.0 字符串插值 对不可变值取地址现在为警告而非错误 Internal 访问级别，可通过 \u0026lsquo;using internal name;\u0026lsquo;（name 为命名空间或类型名）访问 初始化块 \u0026lsquo;this { \u0026hellip; }\u0026rsquo; 运算符优先级调整为与 C#/C++ 一致 改进扩展支持 支持 \u0026lsquo;enum\u0026rsquo; 与 \u0026lsquo;interface\u0026rsquo; 约束 IDE 保存时格式化  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_43_0/",
	"title": "版本 0.43.0",
	"tags": [],
	"description": "",
	"content": "2021 年 2 月 22 日\n 编译期函数求值 编译期代码生成 AttributeUsage 中的 AlwaysIncludeUser 属性 初始化表达式 \u0026lsquo;.{ x = 1, y = 2}\u0026rsquo; 参数级联 \u0026lsquo;UseString(val.ToString(.. scope .()));\u0026rsquo; 自动构造函数 \u0026lsquo;struct Vec : this(float x, float y);\u0026rsquo; Lambda 返回类型推断 运算符重载的 params 支持 ref \u0026lsquo;in\u0026rsquo; 参数 改进 C VarArg 兼容性  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_43_1/",
	"title": "版本 0.43.1",
	"tags": [],
	"description": "",
	"content": "2021 年 11 月 22 日\n 自动属性支持字段析构 溢出运算符（\u0026amp;-, \u0026amp;+, \u0026amp;*） 范围（如：for (int a in 0..\u0026lt;count)、for (int i in 1..^0)） offsetof(T, Member) IDE 支持 TrueType 字体集合  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_43_2/",
	"title": "版本 0.43.2",
	"tags": [],
	"description": "",
	"content": "2022 年 3 月 29 日\n 升级到 LLVM 13.0.1 代码文件生成器替代 \u0026ldquo;New Class\u0026hellip;\u0026rdquo; 编译期文件 IO 与进程创建 分析器线程列表新增 CPU 使用率 算术溢出检查 定长数组 params 泛型转换运算符重载 支持 const string 泛型参数 方法泛型参数部分显式指定，支持 \u0026hellip; 与 ? 编译期 IOnFieldInit 位域 静态局部方法与变量 const 字符串插值 lambda 体内支持 @this 委托引用 委托相等性改进，支持哈希与 == 运算符 编译期自定义特性 IDE 可折叠区域  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_43_3/",
	"title": "版本 0.43.3",
	"tags": [],
	"description": "",
	"content": "2022 年 6 月 20 日\n 文件级命名空间 多 $ 字符串插值 IDE 内嵌 emit 视图 IDE 更好的高刷新率支持 IDE 格式化选项 isconst(expr) 代码块支持 [ConstSkip] 新增预编译的 JEMalloc 与 TCMalloc 库  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_43_4/",
	"title": "版本 0.43.4",
	"tags": [],
	"description": "",
	"content": "2022 年 9 月 7 日\n 新增 System.RefCounted\u0026lt;T\u0026gt; 新增 System.Collections.SplitList\u0026lt;T\u0026gt; SoA 容器 新增 nameof 表达式 命名参数 append 字段 using 字段 定长数组新增 .InitAll 元素初始化器 新增 System.ITypedAllocator 和 System.SingleAllocator IDE 源文件折叠状态序列化 IDE 书签面板  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/releases/ver_0_43_5/",
	"title": "版本 0.43.5",
	"tags": [],
	"description": "",
	"content": "2025 年 3 月 19 日\n IDE 标签固定 新增 IDE 启动面板 新增终端与控制台 IDE 面板 监视窗口中支持搜索 改进 DLL 热编译 新增 \u0026lsquo;?\u0026rsquo; lambda 捕获说明符，自动选择复制或引用 新增 System.IParsable 新增 System.HashCode 新增可处理带载荷枚举的 EnumParser\u0026lt;T\u0026gt; 允许在编译期 \u0026ldquo;prev\u0026rdquo; 特性实例数据的 const 编码上软失败 fallthrough 新增标签支持 新增 \u0026lsquo;const var\u0026rsquo; 泛型参数约束 允许 const struct 泛型参数约束 生成更小的可执行文件 泛型现在可被基础类型约束 新增项目依赖的预处理检查 BF_DEPENDS_\u0026lt;NAME\u0026gt; 包管理（仅 Git） Wasm 改进 构建命令：CopyToTarget 泛型构造函数 新增 IDE 着色选项：Member、Local、Parameter 内联匿名类型声明 在初始化块中支持匿名子类声明 初始化语句中支持初始化块 编译期支持 TypeDeclaration ZeroGap AllowAppend  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/foreward/",
	"title": "简介",
	"tags": [],
	"description": "",
	"content": " Beef 概览 Beef 是一门面向性能、静态编译的编程语言。其语言与环境以开发者生产力为核心，并在开发、调试和维护 Beef 应用的整体体验上投入了大量打磨。目标用户是重视性能、简洁性、代码可读性、快速迭代以及良好可调试性的开发者。\n设计目标  高性能执行  无 GC 或引用计数开销 运行时最小化 编译执行（无 JIT 延迟）  内存可控  广泛支持自定义分配器 增强对栈内存的控制  与 C/C++ 低摩擦互操作  可静态或动态链接常规 C/C++ 库 支持 C/C++ 结构体布局与调用约定  当冗长有助于清晰、可读或可发现性时，宁可冗长而非过度简洁 支持流畅的迭代式开发  快速增量编译与链接 运行时代码编译（热代码替换），支持数据布局变化  面向目标用户的熟悉语法与编程范式（C 系） 良好可调试性  生成标准调试信息（PDB/DWARF） 强调调试构建的执行速度  非常适合 IDE 工作流  编译器即服务 快速且可靠的自动补全 快速且可靠的重构能力（如符号重命名）  利用 LLVM 基础设施  久经考验的后端优化器 支持 ThinLTO 链接时优化   "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/license/",
	"title": "许可证",
	"tags": [],
	"description": "",
	"content": "MIT 许可证\n版权所有 \u0026copy; 2019 BeefyTech\n特此免费授予任何获得本软件及相关文档文件（“软件”）副本的人许可，不受限制地处理本软件，包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或销售软件副本的权利，并允许向其提供软件的人这样做，但须遵守以下条件：\n上述版权声明和本许可声明应包含在软件的所有副本或主要部分中。\n本软件按“原样”提供，不提供任何形式的明示或默示担保，包括但不限于对适销性、特定用途适用性和非侵权性的担保。在任何情况下，作者或版权持有人均不对因本软件或其使用或其他交易而产生的任何索赔、损害或其他责任承担责任，无论该责任源于合同、侵权或其他原因。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/getting-start/building/",
	"title": "从源码构建",
	"tags": [],
	"description": "",
	"content": " 构建概览 对于已有二进制发行版的平台（如 Windows），无需从源码构建。\n源码位于 https://github.com/beefytech/Beef。\n引导构建 Beef 编译器核心使用 C++ 编写，而 IDE 与命令行构建系统 BeefBuild 使用 Beef 本身编写。为实现引导构建，Beef 提供了一个最小引导编译器，其唯一职责是先构建一次 BeefBuild，随后由 BeefBuild 再进行“正式”的自举构建。\n在 Windows 上构建 要求  Visual Studio 2017 或更高版本的 Microsoft C++ 构建工具。可仅安装 Microsoft Visual C++ Build Tools，也可安装完整的 Visual Studio 套件：https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022。 Platform Toolset 141 (VS2017) Windows SDK 10.0.17763.0 CMake 3.15 or newer Python 3.6 or newer Git command line tools  构建步骤  执行 bin/build.bat  注意：该过程会先下载并构建 LLVM，需要一些时间。 构建产物位于 IDE/dist。\n在 Linux 和 macOS 上构建 要求  CMake 3.15 or newer LLVM-18 Git  构建步骤  使用 bin/build.sh 构建 Beef  构建产物位于 IDE/dist。\n请注意，这些平台支持 BeefBuild 等 CLI 工具，但 IDE 目前仅支持 Windows。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/getting-start/",
	"title": "入门指南",
	"tags": [],
	"description": "",
	"content": " 欢迎使用 Beef Beef 主要以 IDE 方式使用，但也支持命令行构建。第一步可以 安装 Beef 或 从源码构建。目前仅提供 Windows 的二进制包，且 Beef IDE 也只支持 Windows。\n支持的平台 Windows 提供二进制包，Windows、Linux 和 macOS 支持从源码构建。包含 Android 和 iOS 在内的目标平台 交叉编译 正在开发中。\n使用 IDE 创建“Hello World”  启动 Beef IDE 选择 File/New/Project 新建项目，创建名为“Hello”的 Console 项目 右键新项目，选择“New Class\u0026hellip;”，名称输入“Program” 在新建文件中输入以下内容  using System; namespace Hello { class Program { static void Main() { Console.WriteLine(\u0026#34;Hello, world!\u0026#34;); } } }   按 F5 编译并运行  使用命令行创建“Hello World”  在任意位置创建名为“Hello”的目录 在终端中进入该目录 运行 BeefBuild -new 在该目录初始化新的工作区和项目 创建 src/Program.bf 文本文件，并粘贴上方代码 运行 BeefBuild -run 编译并执行  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/basics/",
	"title": "基础知识",
	"tags": [],
	"description": "",
	"content": " 编译模型 Beef 的编译上下文是工作区，由多个项目组成。项目可以是库，也可以生成可执行文件或 DLL 等二进制。源文件会被解析、经过有限预处理、编译，并为被引用的类型与方法构建一组目标文件，最终链接为目标二进制。工作区级的编译模型允许以工作区为单位的设置影响特定方法或类型的编译，即便代码位于引用的第三方库中，也可修改预处理与编译设置（如优化级别）。\n支持增量编译，通过依赖图仅重建可能受影响的对象，并使用后端缓存避免对无功能变化的对象重建。可关闭增量编译以生成可复现的构建。\nBeef 支持多种编译器后端，包括 LLVM 以及自定义的 “增强调试”（Og+）后端，该后端在不影响可调试性的前提下进行部分优化，并在调试信息输出方面优于 LLVM。\n支持多种链接器，包括系统链接器，以及可用于链接时优化构建（LLVM LTO/ThinLTO）的 LLVM 链接器。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/datatypes/members/",
	"title": "类型成员",
	"tags": [],
	"description": "",
	"content": " 字段 字段可以是 const、static 或实例字段。const 字段表示值，但不占用内存；在简单的常量算术求值下，const 必须在编译期求值为常量。使用 const 等同于使用其对应的字面量值。static 值是在定义类型命名空间内的单个“全局变量”。既非 static 也非 const 的字段为实例字段，表示定义类型实例内部的数据。\nclass Widget { /* 静态“共享”值 */ static int totalCount; const int MaxWidgets = 64 * 1024; /* 普通“实例”数据字段 */ int x; int y; }  通过 using 字段支持匿名字段访问。标记为 using 的字段，其成员字段可在不使用字段名限定的情况下直接访问。这种用法对命名字段本身与匿名使用有不同的访问级别。例如 public using private Vector2 mPosition 中，mPosition 为 private，但通过匿名访问时其 X 与 Y 成员是 public 可见。\n匿名字段访问可以通过组合提供一些类似继承的优势。\nstruct Vector2 { public float X; public float Y; } struct Entity { /* 可直接访问 \u0026#39;mX\u0026#39; 或通过 \u0026#39;mPosition.mX\u0026#39; 访问。注意匿名访问未直接指定访问级别， 因此采用命名字段的访问级别（public） */ using public Vector2 mPosition; public int32 mHealth; }  追加字段是一种优化，允许引用类型字段的数据静态包含在所属对象内部。这样字段在语义上仍表现为引用类型，但无需引用类型的间接访问（数据偏移已静态确定），也无需单独分配。\n/* 分配 \u0026#39;User\u0026#39; 时会包含两个成员字符串的数据，以及它们内部缓冲区的指定空间 */ class User { public append String mName = .(256); public append String mPassword = .(32); }  方法 Beef 支持方法重载。对于泛型重载，若约束不同，允许存在同名泛型方法的多个版本。若多个泛型方法同时匹配，当其中一个的约束是另一个的超集时，可视为“更好”的匹配；否则重载选择将产生歧义。\n参数值默认为不可变，除非使用 ref、out 或 mut 标记。in 标记可显式要求以不可变引用传参，但这会禁止在更高效的情况下以值传递小型结构体，因此只有在确需该语义时才应使用 in。\nbool GetInt(out int outVal) { outVal = 92; return true; } /* \u0026#39;mut\u0026#39; 可用于可能是值类型或引用类型的泛型，但需要可变引用。 \u0026#39;mut\u0026#39; 对引用类型无影响，但对值类型会被视为 \u0026#39;ref\u0026#39;。 */ bool DisposeVal\u0026lt;T\u0026gt;(mut T val) where T : IDisposable { val.Dispose(); } /* 方法可以返回 \u0026#39;ref\u0026#39; 或 \u0026#39;readonly ref\u0026#39; 值 */ readonly ref int Get() { return ref mVal; }  方法可使用参数名调用。命名参数可按任意顺序出现，并可与普通“位置”参数混用，但有一定限制。\nstatic void Method(int a, int b, int c) {} /* 合法 */ Method(1, 2, 3); Method(a:1, b:2, c:3); Method(a:1, 2, c:3); Method(c:3, b:2, a:1); /* 非法 */ Method(a:1, a:2, b:3, c:4); Method(b:2, 1, 3);  当需要将参数视为可修改的“初始值”时，可使用变量遮蔽功能：语义上会创建参数的可修改副本，并生成同名的新遮蔽变量。\nvoid Write(char8 c) { var c; if (c == \u0026#39;\\n\u0026#39;) c = \u0026#39; \u0026#39;; file.Write(c); /* 原始参数仍可通过 \u0026#34;@c\u0026#34; 访问，并可在调试构建的调试器中查看 */ }  默认情况下，“较大”的结构体以不可变引用传递，“较小”的结构体以不可变值传递。诸如 Vector3 的结构体可在 x86 上直接通过 XMM 寄存器传递。\n可变参数数量 可以通过在最后一个参数上使用 \u0026ldquo;params\u0026rdquo; 标记来定义可变参数方法。这在 Console.WriteLine 等字符串格式化方法中很常见。\u0026rdquo;params\u0026rdquo; 类型可声明为数组或 Span 类型。\u0026rdquo;params\u0026rdquo; 也可用于委托或函数类型，从而将参数声明展开为该委托/函数的参数列表——这对于泛型参数转发很有用，如 System.Event 的场景。\n/* 可变参数 */ void Draw(String format, params Object[] args) { let str = scope String(); /* 使用 \u0026#39;params\u0026#39; */ str.AppendF(format, params args); } /* 委托参数转发 */ public static rettype(T) SafeInvoke\u0026lt;T\u0026gt;(T dlg, params T p) where T : Delegate { if (dlg == null) return default; return dlg(params p); }  泛型元组 params 允许按参数进行泛型特化。通常会使用编译期代码生成，为传入参数类型生成特化的方法体。高级示例参见 https://github.com/beefytech/Beef/blob/master/IDEHelper/Tests/src/Params.bf 的快速字符串格式化测试实现。\nvoid HandleArgs\u0026lt;TArgs\u0026gt;(params TArgs args) where TArgs : Tuple { } HandleArgs(\u0026#34;String\u0026#34;, 1, 2.3f);  Beef 支持与 C 兼容的可变参数。这比 params 更不安全，因为参数数量与类型未知，但对 C 互操作很有用。\n/* 外部 C 方法 \u0026#39;void Log_External(char*, va_list)\u0026#39; */[CLink] static extern void Log_External(char8* format, void* varArgs); public static void Log(String format, ...) { VarArgs vaArgs = .(); vaArgs.Start!(); Log_External(format, vaArgs.ToVAList()); vaArgs.End!(); return result; } public static void HandleVarArgInts(int count, ...) { VarArgs vaArgs = .(); vaArgs.Start!(); for (int i \u0026lt; count) Dispay(vaArgs.Get!\u0026lt;int\u0026gt;()) vaArgs.End!(); return result; }  内联 后端优化会执行内联，但你也可以通过 [Inline] 特性显式内联方法。这会进行直接内联，即使在调试构建中也会内联（不影响可调试性），并确保方法在可能无法自动内联的场景下也能内联，例如非 LTO 的跨模块调用。\nclass Collection {[Inline] int GetLength() { return mLength; } void Clear() { mLength = 0; } } void Use(Collection c) { c.GetLength(); /* 可在调用点请求 Inline，会创建一个局部的“总是内联”版本来调用 */ c.[Inline]Clear(); }  丢弃的返回值 方法提供一定的安全机制以防止丢弃返回值。这有助于确保错误被处理，或避免把返回修改值的方法误认为是原地修改。可通过为方法添加 [NoDiscard] 特性，在丢弃结果时生成静态警告。对于未处理错误的场景，可在返回类型上添加 ReturnValueDiscarded() 方法，编译器会在运行时调用——内置的 Result 类型就使用了这一机制（参见 错误处理）。\n[NoDiscard] char8 ToUpperCase(char8 c); void ToUpperCase(String str) { for (var c in ref str.RawChars) { /* 糟糕 - 这里会抛出“返回值被丢弃”的警告。原意是写 \u0026#39;c = ToUpperCase(c)\u0026#39; */ ToUpperCase(c); } }  Mixin Mixin 是一种会被直接“混入”调用点的方法，而不是被“调用”。这不仅能消除调用开销，还具有不同语义：mixin 中的 break 可直接跳出调用者的结构块，return 也会从调用者返回。\nstatic mixin Inc(int* val) { if (val == null) return false; (*val)++; } static bool Inc3(int* a, int* b, int* c) { Inc!(a); Inc!(b); Inc!(c); return true; }  Mixin 参数类型也可通过声明为 var 来“解除约束”，有助于创建更通用的类宏辅助。Mixin 也可使用带约束的泛型参数实现，这有助于生成更有用的错误或在存在多个重载版本时进行选择，但不影响代码生成。使用 var 不会带来性能损耗，因为 mixin 在调用点的展开方式相同——区别仅在于错误发生在调用点表达式本身还是展开后的 mixin 内部。\n当指定 mixin 参数类型时，如果调用者传入的可变值与类型匹配，该参数将是可变的；否则会发生类型转换，参数将不可变。\nMixin 不声明返回类型，因为它们不“返回”，但可使用“表达式块”语法产生值：mixin 定义块以不带分号的表达式结尾。\nstatic mixin Max(var a, var b) { (a \u0026gt; b) ? a : b }  Mixin 目标 在 mixin 定义中，对于允许指定作用域目标的操作（如 break、continue、scope 分配），可使用特殊的 mixin 目标，使作用域目标可在 mixin 调用点指定。\nstatic mixin AllocString() { scope:mixin String() } void Use() { String outerStr = null; while (IsRunning()) WhileBody: { String whileStr = null; if (Check()) { // 在当前作用域分配字符串 \tlet localStr = AllocString!(); // 在 \u0026#39;while\u0026#39; 体作用域中分配字符串 \twhileStr = AllocString!:WhileBody(); // 在方法作用域中分配字符串 \touterStr = AllocString!::(); } } }  属性 属性用于向类型添加具名值，并定义 getter 和/或 setter 方法。\nstruct Square { int x; int y; int width; int height; public int Right { get { return x + width; } /* 注意这里要求使用 \u0026#39;mut\u0026#39; */ set mut { width = value - x; } } /* 允许按引用返回 \u0026#39;Left\u0026#39;，从而可通过赋值设置其值， 同时也可按引用传递给其他方法 */ ref int Left { get { return ref x; } } /* 该属性定义会隐式创建成员变量以及相应的 get/set 方法 */ uint32 Color { get; set; } = 0xBFBF; } struct IntRef { int* mValue; public ref int Ref { get { return ref *mValue; } /* 若没有 \u0026#39;ref\u0026#39; 标记，set 方法会接收 \u0026#39;int\u0026#39; 而非 \u0026#39;ref int\u0026#39; */ set ref mut { mValue = \u0026amp;value; } } public ref int Value =\u0026gt; ref *mValue; }  索引运算符是带一个或多个索引参数的属性。\npublic ReadOnlyList\u0026lt;T\u0026gt; { public T this[int idx] { get { return mList[idx]; } } }  成员访问 默认情况下，结构体与类成员为 \u0026lsquo;private\u0026rsquo;，仅能在该类型内部访问。\u0026rsquo;protected\u0026rsquo; 成员可被派生类型访问，\u0026rsquo;public\u0026rsquo; 成员可被任何人访问。\u0026rsquo;internal\u0026rsquo; 成员可在指定 using internal \u0026lt;namespace\u0026gt; 的文件中访问。\u0026rsquo;protected internal\u0026rsquo; 是 \u0026lsquo;protected\u0026rsquo; 与 \u0026lsquo;internal\u0026rsquo; 的最宽松组合。注意即便位于同一命名空间的类型，也需要显式指定 using internal 才能访问彼此的 internal 成员。\n/* 允许我们在 \u0026#39;GameEngine\u0026#39; 命名空间内的任意位置访问 internal 成员 */ using internal GameEngine; class Widget { private int32 id; protected Rect pos; public uint32 color; internal void* impl; } class Button : Widget { /* 该类可访问 \u0026#39;pos\u0026#39; 和 \u0026#39;color\u0026#39;，但不能访问 \u0026#39;id\u0026#39; */ } static void Main() { var button = new Button(); /* 我们只能访问 \u0026#39;button.color\u0026#39; */ /* [Friend] 特性允许访问通常被隐藏的成员 */ int32 id = button.[Friend]id; /* 注意这里的 \u0026#39;friend\u0026#39; 关系与 C++ 相反 —— 使用者承诺“友好”， 而不是由定义类型声明其友元 */ } "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/datatypes/attributes/",
	"title": "特性",
	"tags": [],
	"description": "",
	"content": " 类型特性  [CRepr] - 将结构体标记为 C 兼容 [Ordered] - 禁用字段重排（字段重排用于减少对齐填充） [Packed] - 省略字段对齐填充 [Union] - 对结构体创建联合体  成员特性  [Reflect] - 强制为该成员生成反射数据 [NoShow] - 在自动补全中隐藏该字段  静态字段或方法特性  [CLink] - 使用 C 链接名而非 C++ 风格重整 [LinkName] - 显式覆盖链接名  构造函数特性  [AllowAppend] - 允许追加分配  方法特性  [AlwaysInclude] - 表示即使按需编译会跳过该方法，也应将其包含在构建中。适用于需要通过反射调用的方法。 [Checked] - 表示该方法执行运行时检查（如参数校验/越界检查） [Commutable] - 为该方法生成一个参数前两位交换的额外版本，可用于可交换运算符 [Comptime] - 标记方法仅可在编译期求值，不可在运行期调用 [DisableChecks] - 表示该方法内部调用尽可能使用 Unchecked 版本的方法（优化） [DisableObjectAccessChecks] - 表示在该方法内禁用对象访问检查（优化） [Error] - 调用该方法时抛出编译错误（[Obsolete] 的更通用形式） [Export] - 导出该方法 [Import] - 从指定 DLL 导入方法，可用于没有 DLL 的 lib 文件时 [Inline] - 即使在非优化构建中也内联函数 [Intrinsic] - 将方法绑定为 intrinsic（通常仅用于系统库） [NoDiscard] - 若返回值未使用，则在调用点发出警告 [NoReturn] - 表示该方法不会返回 [Obsolete] - 标记方法过时，抛出警告或错误 [Optimized] - 在启用优化的情况下编译方法 [SkipCall] - 禁止生成对该方法调用以及参数求值的代码 [StdCall] - 使用 stdcall 调用约定而非默认 cdecl [Test] - 标记方法为测试方法 [Unchecked] - 表示该方法省略运行时检查（通常用于性能） [Warn] - 调用该方法时抛出编译警告（[Obsolete] 的更通用形式）  静态字段特性  [ThreadStatic] - 将该字段标记为线程本地静态字段  成员访问特性  [Friend] - 允许访问私有成员 [SkipAccessCheck] - 对该成员访问目标省略对象访问检查（优化）  代码块特性  [IgnoreErrors] - 静默忽略该代码块中的错误  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/datatypes/initialization/",
	"title": "初始化",
	"tags": [],
	"description": "",
	"content": " 初始化 类的初始化语义如下：先将对象清零，然后按声明顺序执行根类字段初始化器，接着按声明顺序执行初始化块，然后运行根类构造函数，之后依次执行派生类的字段初始化器、初始化块和构造函数。即使在基类构造函数中调用虚方法，也会派发到最派生类型，这可能导致在某个类型构造函数尚未执行时就调用了该类型的方法。\nclass Person { public String mFirstName = GetFirstName(); public String mLastName = GetLastName(); public this() { AddPerson(); } } class Student : Person { public School mSchool = GetSchool(); public int? mAge; /* 初始化块无论调用哪个构造函数都会执行 */ this { RegisterStudent(); } public this() { } public this(int age) { mAge = age; } } /* 构造 Student 时，初始化顺序如下： mFirstName = GetFirstName() mLastName = GetLastName() AddPerson(); mSchool = GetSchool() RegisterStudent(); */ /* 类或结构体及其继承者或扩展也可以选择忽略所有初始化器，保留清零后的类/结构体 */ extension Person { /* 为 Person 添加一个构造函数，因使用 \u0026#39;this(?)\u0026#39; 而不调用 GetFirstName()/GetLastName() */ /* 派生类也可通过 base(?) 达到同样效果 */ public this(String firstName, String lastName) : this(?) { /* 此时 mFirstName 与 mLastName 仍为 null */ mFirstName = firstName; mLastName = lastName; AddPerson(); } }  对于结构体初始化语义，结构体不会自动清零——字段初始化器与构造函数必须共同完成所有字段的初始化。结构体的使用者也可以选择不执行构造函数，而是直接手动初始化所有字段。未完全初始化的结构体使用会在简单的静态分析中被禁止，但可通过显式的 \u0026ldquo;?\u0026rdquo; 未初始化表达式覆盖。\n/* 在此示例中，我们知道 \u0026#34;UseVec\u0026#34; 会初始化 Vector2，因此使用 \u0026#39;?\u0026#39; 以避免“未初始化”错误 */ Vector2 vec = ?; UseVec(\u0026amp;vec);  分配时也支持数组初始化。\n/* 将末尾 7 个元素清零初始化 */ int[] iArr = new int[10] (1, 2, 3, ); /* 末尾 7 个元素保持未初始化 */ int[] iArr = new int[10] (1, 2, 3, ?); /* 抛出初始化大小不匹配错误 - 若希望清零初始化，需要结尾逗号 */ int[] iArr = new int[10] (1, 2, 3);  值初始化器允许在创建时为字段与属性赋值。\n/* 构造 Cat，调用默认构造函数，然后赋值 Age 与 Name 属性 */ var cat = new Cat() { Age = 10, Name = \u0026#34;Fluffy\u0026#34; };  对于结构体，值初始化器也可以在不调用任何构造函数或初始化块的情况下使用。\nstruct WindowInit { public width = 1280; public height; this { height = 720; } } /* 默认构造函数 + 值初始化器：height 为 720，width 为 1280，然后被设为 1920 */ var init = WindowInit() { width = 1920 } /* 等价于 */ var init = WindowInit(); init.width = 1920; /* 仅值初始化器：height 为 0，width 为 0，然后被设为 1920 */ var init = WindowInit { width = 1920 } /* 等价于 */ WindowInit init = default; // Struct is zeroed init.width = 1920;  值初始化器还允许在创建时向集合添加项。可以提供表达式列表，它们会分别传给适用的 Add 方法。\nvar list = scope List\u0026lt;int\u0026gt;() {1, 2, 3, 4}; var weightDict = scope Dictionary\u0026lt;String, float\u0026gt;() { (\u0026#34;Roger\u0026#34;, 212.3f), (\u0026#34;Sam\u0026#34;, 110.2f) };  类型也可以定义静态字段与静态构造函数。静态初始化顺序由完全限定类型名的字母数字顺序决定。可使用 [StaticInitPriority(\u0026hellip;)] 与 [StaticInitAfter(\u0026hellip;)] 等类型特性覆盖该顺序。若静态初始化引用了其他类型的静态字段，会在访问前按需执行该类型的静态初始化器。不过，这种按需初始化可能导致循环依赖，处理方式是直接跳过重入的初始化调用。\n析构 类可以定义析构函数。通常析构顺序与初始化顺序相反。\nclass Person { public String mFirstName = GetFirstName() ~ delete _; public String mLastName = GetLastName() ~ delete _; public this() { AddPerson(); } public ~this() { RemovePerson(); } } class Student : Person { public School mSchool = GetSchool() ~ ReleaseSchool(_); public this() { RegisterStudent(); } public ~this() { UnregisterStudent(); } } /* 删除 Student 时，反初始化顺序如下： UnregisterStudent() ReleaseSchool(mSchool) RemovePerson() delete mLastName delete mFirstName */  结构体不能定义析构函数，但可定义包含反初始化代码的 Dispose 方法。Dispose 可与 using 或 defer 语句配合，以 “RAII 风格”（作用域退出时调用）使用。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/safety/",
	"title": "安全特性",
	"tags": [],
	"description": "",
	"content": " Beef 支持多种可选安全特性，其中许多可针对特定代码组关闭，用于“混合安全”构建（例如性能关键代码可关闭部分检查，而性能要求较低或测试不足的代码则启用更多安全检查）。\n默认情况下，以下检查在 Debug 构建中对所有代码启用，在 Release 构建中禁用。\n越界检查 越界检查在标准库中针对数组、集合、Span 和字符串实现。许多类型提供一个执行越界检查的 [Checked] 访问器，以及一个不做越界检查的 [Unchecked] 访问器，从而可在调用点选择是否检查，而非由集合整体决定。\n// Disable bounds checking for this specific index \tint val = arr[[Unchecked]i]; // Don\u0026#39;t do any checks in this method [DisableChecks] void Calculate() { int val = arr[i]; }  动态转换检查 将对象显式转换为无效的派生类型会在运行时被捕获。\n内存泄漏 使用调试内存管理器可实时检测泄漏。运行时会持续追踪可达内存，不再可达但尚未正确释放的内存会立刻报告为泄漏，并附带分配发生位置。该分配追踪的栈深度可调整。\n重复释放 / 释放后使用 启用调试内存管理器时，请求释放的对象会被标记为“已释放”，但其内存不会立即回收，直到不再有引用指向该内存。任何在标记为已释放后继续使用该内存的行为都会立即失败，并且释放对象的值与分配栈追踪在调试器中仍然可用且可见。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/datatypes/extensions/",
	"title": "扩展",
	"tags": [],
	"description": "",
	"content": " 类型扩展 类型定义可以被扩展，用户项目甚至可以扩展核心库中定义的类型，并添加额外数据字段。\n/* 为线程创建添加时间戳。可在用户代码任意位置包含。 */ namespace System.Threading { extension Thread { DateTime mCreateTime = DateTime.Now; } }  泛型类型可以基于匹配的接口约束进行条件扩展。\nnamespace System.Collections { extension List\u0026lt;T\u0026gt; where T : IOpComparable { public T GetMax() { if (mSize == 0) return default; T max = this[0]; for (let val in this) { // 没有 IOpComparable 约束，这个 \u0026#39;\u0026gt;\u0026#39; 检查会失败 \tif (val \u0026gt; max) max = val; } return max; } } }  扩展可用于为不受你控制的类型（如系统类型或其他库中的类型）添加接口一致性。\n注意扩展中定义的方法遵循依赖可见性规则：只有当调用点所在项目依赖于定义该方法的项目，或者某个泛型参数所在项目依赖于定义该方法的项目时，方法才可被调用。这同样适用于运算符重载——例如为 System.Collections.List\u0026lt;T\u0026gt; 提供 operator== 重载时，该重载不会在 corlib 或其他库内部对 List\u0026lt;T\u0026gt; 的相等比较中被调用。\n扩展可以提供构造函数、析构函数和字段初始化器。\nnamespace System.Collections { extension List\u0026lt;T\u0026gt; {\tpublic int mID = GetId(); /* 此构造函数的可见性遵循上述规则。 */ /* 仍需调用根定义的构造函数进行初始化，因此在此调用它。注意若没有 `[NoExtension]` 将会递归调用自身 */ public this() :[NoExtension]this() { } /* 无论调用哪个构造函数，该初始化块都会执行 */ this { RegisterList(this); } /* 该析构函数在根定义的析构函数之前运行 */ public ~this() { UnregisterList(this); } }  扩展还可通过提供方法声明并由依赖项目实现的方法来反转项目间依赖关系。这种技术提供了虚方法之外的静态派发方案。\n/* In project \u0026#39;Engine\u0026#39; */ class Platform { public extern Texture CreateTexture(); } /* In project \u0026#39;DirectXEngine\u0026#39; */ extension Platform { public override Texture CreateTexture() { return new DirectXTexture(); } }  我们还可以使用扩展在不需要子类的情况下重写虚方法。其优点是不需要重载，但缺点是仍为动态派发。\n/* In project \u0026#39;Engine\u0026#39; */ class Platform { public virtual Texture CreateTexture() =\u0026gt; null; } /* In project \u0026#39;DirectXEngine\u0026#39; */ extension Platform { public override Texture CreateTexture() { return new DirectXTexture(); } }  扩展方法 扩展方法可在不修改原始类型的情况下为现有类型“虚拟地”添加方法。扩展方法是静态方法，但调用方式与被扩展类型的实例方法类似，或用于满足一组泛型约束的类型。当你希望将方法范围限制在特定命名空间或工具方法中，或该方法面向符合特定泛型约束的广泛类型时，扩展方法比类型扩展更合适。\n/* 在全局命名空间为 String 提供 CharCount 方法 */ static { public static int CharCount(this String str, char8 c) { int total = 0; for (let checkC in str.RawChars) if (checkC == c) total++; return total; } } /* 为任何可相加的 T 提供 List\u0026lt;T\u0026gt;.Total 方法。 该方法仅在使用 \u0026#39;using static\u0026#39; 显式导入该类型时可见 */ static class ListUtils { public static T Total\u0026lt;T\u0026gt;(this List\u0026lt;T\u0026gt; list) where T : IOpAddable { T total = default; for (let val in list) total += val; return total; } } /*************************************************/ int charCount = \u0026#34;Test string\u0026#34;.CharCount(\u0026#39;s\u0026#39;); using static ListUtils; int GetListTotal(List\u0026lt;int\u0026gt; list) =\u0026gt; list.Total(); "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/",
	"title": "语言指南",
	"tags": [],
	"description": "",
	"content": " 语言指南概览 Beef 生态由语言、核心库以及 Beef 工具（含 IDE）组成。虽然三者紧密协作，但本节文档仅覆盖语言本身。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/memory/",
	"title": "内存管理",
	"tags": [],
	"description": "",
	"content": " 内存分配 分配可以发生在栈、全局分配器或自定义分配器上。栈分配使用 \u0026ldquo;scope\u0026rdquo; 关键字，可指定从当前作用域（如代码块）到整个方法的作用域（即使在循环中）。\nstatic void Test(StreamReader fs) { let strList = scope List\u0026lt;String\u0026gt;(); for (let line in fs.Lines) { /* 该字符串的作用域为整个方法 */ let lineStr = scope:: String(line); strList.Add(lineStr); } strList.Sort(); } static void Test(StreamReader fs) { Sort: { let strList = scope List\u0026lt;String\u0026gt;(); for (let line in fs.Lines) { /* 该字符串的作用域为 \u0026#34;Sort\u0026#34; 作用域 */ let lineStr = scope:Sort String(line); strList.Add(lineStr); } strList.Sort(); } }  作用域分配可能动态增加栈大小，需要确保为给定计算提供足够的栈空间，就像递归方法必须保证递归深度不会耗尽栈一样。\n通过全局分配器分配使用 \u0026ldquo;new\u0026rdquo; 关键字。\nString AllocGlobalString(int len) { return new String(len); }  通过自定义分配器分配时，使用带自定义分配器实例的 \u0026ldquo;new\u0026rdquo; 关键字。\nString AllocCustomString(int len) { return new:customAllocator String(len); }  自定义分配器最少只需实现一个 Alloc 方法，但可额外实现 AllocTyped 方法以添加类型特定的分配逻辑。内存通过 Free 方法释放。\nstruct ArenaAlloc { public void* Alloc(int size, int align) { return Internal.StdMalloc(size); } public void* AllocTyped(Type type, int size, int align) { void* data = Alloc(size, align); if (type.HasDestructor) MarkRequiresDeletion(data); return data; } public void Free(void* ptr) { Internal.StdFree(ptr); } public void MarkRequiresDeletion(void* obj) { /* TODO: 当分配器释放时调用该对象的析构函数 */ } }  注意：若启用了实时泄漏检查，而自定义分配器使用的内存未被泄漏检查器追踪，则分配器需要报告其内存以便扫描对象引用。可参考 corlib 的 BumpAllocator，特别是其中的 \u0026lsquo;GCMarkMembers\u0026rsquo; 方法，了解如何与泄漏检查器协作。\n自定义分配也可通过 mixin 进行，甚至可以根据条件在栈上分配。例如 ScopedAlloc mixin 会在栈上进行小规模分配，在堆上分配较大对象。\nstatic mixin ScopedAlloc(int size, int align) { void* data; if (size \u0026lt;= 128) { data = scope:mixin[Align(align)] uint8[size]* { ? }; } else { data = new[Align(align)] uint8[size]* { ? }; defer:mixin delete data; } data } void ReadString(int reserveLen) { String str = new:ScopedAlloc! String(reserveLen); defer delete:null str; UseString(str); }  注意上述示例中使用了 delete:null。ScopedAlloc! 调用会释放实际分配的内存，但不会调用 String 的析构函数。如果 UseString 向 str 追加了超过 reserveLen 的数据，则会发生堆分配，需要由 String 析构函数释放。delete:null 允许你执行析构而不请求释放任何内存。\n许多 corlib 类（如 System.String 和 System.Collections.List）需要动态分配内存。按惯例，这些类从全局分配器分配，并通过 String.Alloc、String.Free 等虚方法重写支持其内部使用自定义分配器。\n全局分配器 全局分配器以工作区为单位选择。默认使用 CRT malloc/free 分配器，但也可使用任意 C 风格全局分配器，如 TCMalloc 或 JEMalloc。此外，Beef 还提供特殊的调试分配器，用于实时泄漏检查与热编译等功能。\nBeef 的分配是 C 风格的：不可移动，且没有垃圾回收器。\n释放内存 作用域分配会在作用域结束时自动释放，但手动分配必须使用 \u0026ldquo;delete\u0026rdquo; 关键字手动释放。与自定义分配器分配类似，delete 也可以指定自定义分配器目标来释放该分配器的内存。\n追加分配 追加分配是一类可放在构造函数中的特殊分配，可在分配所属对象时手动请求额外内存。这在 corlib 中用于接受 \u0026ldquo;size\u0026rdquo; 参数的字符串等场景。\nclass FloatArray { int mLength; float* mPtr;[AllowAppend] public this(int length) { let ptr = append float[length]*; mPtr = ptr; mLength = length; } } /* 追加分配保证紧随对象自身内存之后（考虑对齐）。我们可以利用这一点计算数组存储位置，而不需要在内部保存指针。 注意这里使用了 \u0026#34;ZeroGap\u0026#34; 属性，确保没有类能扩展该类型并添加字段，从而破坏追加位置的假设。 */ class FloatArray { int mLength;[AllowAppend(ZeroGap=true)] public this(int length) { let ptr = append float[length]*; mLength = length; } public float* Ptr { get { return (float*)(\u0026amp;mLength + 1); } } }  在内部，追加分配通过在分配发生前调用尺寸计算函数来实现。编译器会尝试对该函数及其在调用点的相关参数进行常量求值，从而得到固定大小的分配而非动态大小分配，这样可省去额外调用，并可能提升某些栈分配的性能。\n追加分配的内存不需要显式释放，但仍可通过 delete:append obj 语句调用对象析构函数。\n装箱 所有值类型（基础类型、结构体、元组、指针、枚举）都可“装箱”为 Object，这对于动态类型处理与接口派发很有用。基础类型都对应库内定义的结构体包装，用于装箱（例如 int32 会被 System.Int32 包装）。装箱是分配操作，转换为 System.Object 时会隐式进行临时栈分配，但也可显式指定长期装箱与更长生命周期的栈分配。装箱值类型时，会静态生成一个包裹该值类型的特殊“盒类型”。这会带来一定代码膨胀，因此这些盒类型按需为每个值类型生成。\n// 格式化调用依赖装箱以处理传入类型 Console.WriteLine(\u0026#34;a + b = {}\u0026#34;, a + b); Object a = 1.2f; // 隐式在栈上装箱到当前作用域 Object b = scope box:: 2.3f; // 显式在栈上装箱到方法作用域 Object c = new:allok box 4.5f; // 通过自定义分配器 \u0026#39;allok\u0026#39; 显式装箱  Variant System.Variant 是装箱的替代方案。Variant 不是对象类型，因此无法进行动态接口派发，但其优势是可在不分配的情况下存储小型数据类型，且不会产生装箱代码膨胀。Variant 可通过 Variant.GetBoxed 转换为堆分配的装箱对象，但如果编译器尚未为存储的值类型生成按需盒类型，该操作会失败。可通过 反射选项 明确请求生成盒类型。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/datatypes/anon/",
	"title": "匿名类型",
	"tags": [],
	"description": "",
	"content": " 匿名类型声明 匿名类型声明与普通类型声明类似，但它们没有名称，并放在通常写类型引用的位置。\n[Union] struct Vector3 { public float[3] vals; /* 带匿名字段的匿名结构体声明。 下面等价于： public using struct { public float mX; public float mY; public float mZ; } _UNUSED_NAME_; */ public struct { public float x; public float y; public float z; }; /* 匿名枚举声明 */ public enum { Left, Center, Right } GetXDirection() =\u0026gt; (mX \u0026lt; 0) ? .Left : (mX \u0026gt; 0) ? .Right : .Center; } Vector3 vec = .(); vec.mX = 1; vec.mY = 2; vec.mZ = 3; /* 类型可以匿名扩展与重写 */ var buttonWidget = new ButtonWidget(\u0026#34;OK\u0026#34;) { bool wasClicked; public override void OnClick() { base.OnClick(); wasClicked = true; CloseDialog(); } }; "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/namespaces/",
	"title": "命名空间",
	"tags": [],
	"description": "",
	"content": " 命名空间概览 命名空间用于在 Beef 中组织类型并防止命名冲突。注意，命名空间中的元素始终是 public。\nnamespace Gfx { // Defines \u0026#34;Gfx.Window\u0026#34; class \tclass Window { } namespace Resources { // Defines \u0026#34;Gfx.Resources.Image\u0026#34; class \tclass Image { } } } namespace Gfx.Resources { // Defines \u0026#34;Gfx.Resources.Shader\u0026#34; class \tclass Shader { } }  使用命名空间 虽然类型可以使用完全限定名来引用，但如果在该文件中通过 using 指令列出了其所属命名空间，就可使用更短的未限定名。\nusing Gfx.Resources; class Program { void Use() { // Shader refers to Gfx.Resources.Shader; \tlet s = new Shader(); } } "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/datatypes/",
	"title": "数据类型",
	"tags": [],
	"description": "",
	"content": " 基本数据类型 Beef 提供以下基础类型：\n整数类型  int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64  int 与 uint 使用平台原生整数宽度，并被视为独立类型，而非显式大小类型（如 int64/uint64）的别名。\n浮点类型  float double  字符类型 字符类型只指定大小而不指定编码。例如 char8 可以表示 UTF8 的一个字节或一个 ASCII 字符，具体取决于上下文。\n char8 char16 char32  无值类型  void  布尔类型  bool  结构体 结构体是用户定义的值集合，类似于 C 中的 struct。结构体可包含字段、属性、方法，并可定义内部类型。对 C++ 程序员而言，这些结构体类似 C++ POD，不支持虚方法或拷贝构造函数。\nstruct Vector { public float x; public float y; /* 默认构造函数 - 构造函数必须设置所有字段 \u0026#34;this = default;\u0026#34; 等价于 \u0026#34;x = 0; y = 0;\u0026#34; */ public this() { this = default; } /* 带参数构造函数 */ public this(float x, float y) { this.x = x; this.y = y; } /* 计算长度的属性 */ public float Length { get { return Math.Sqrt(x*x + y*y); } } /* 结构体的方法需声明为 \u0026#39;mut\u0026#39; 才能修改结构体 */ public void SetZero() mut { x = 0; y = 0; } }  结构体可以为零大小，这使某些泛型模式得以高效实现，而这些在不允许零大小结构体的 C++ 中需要其他方法。另外，Beef 的结构体设计为比 C 的对应结构体产生更少的“对齐空洞”：字段按对齐大小排序，次级再按声明顺序排序；在 Beef 中结构体大小与步长是不同概念，而 C 中结构体大小总是按最大成员对齐，因此等同于步长。字段重排可通过 [Ordered] 特性禁用，结构体可通过 [CRepr] 标记为完全 C 互操作。字段对齐打包可通过 [Packed] 禁用。可用 [Union] 创建联合体。\nstruct StructA { int32 i; int64 j; } struct StructB : StructA { int8 k; } struct StructC : StructB { int8 l; } /* 在 Beef 中，StructC 仅占 14 字节，而在 C 中则为 24 或 32 字节 （取决于实现）。 Beef: sizeof(StructA) = 12 strideof(StructA) = 16 sizeof(StructB) = 13 strideof(StructB) = 16 sizeof(StructC) = 14 strideof(StructC) = 16 C/C++: sizeof(StructA) = 16 sizeof(StructB) = 24 sizeof(StructB) = 32（或 24） 在 Beef 中，由于字段重排消除了对齐填充，数据大小更小。C 中，StructB 新增的 \u0026#39;k\u0026#39; 字节 会导致额外 7 字节填充。StructC 新增的 \u0026#39;l\u0026#39; 字节在某些编译器（VC）上会再增加 7 字节填充， 而其他编译器会将 \u0026#39;l\u0026#39; 填入之前的填充中（Clang/GCC）。 */ /* 自动构造函数为简单数据类型提供简写。 以下两种类型定义等价 */ struct Vector3 : this(float x, float y, float z); struct Vector3 { public float x, y, z; public this(float x, float y, float z) { this.x = x; this.y = y; this.z = z; } }  通过省略结构体主体可创建不透明结构体定义，用于互操作且不允许直接分配（因为大小未知）。\n元组类型 元组是一种特殊的结构体。其语法可更简洁地表达某些代码模式，但不能定义属性或方法。\nlet tup = (1, 2); // 无名称成员 int sum = tup.0 + tup.1; // 按位置访问 let (first, second) = tup; // 解构到新变量 let coords = (x: 2, y: 3); // 有名称成员 let len = Math.Sqrt(coords.x*coords.x + coords.y*coords.y); // 按名称访问  (uint, uint) utup = (1, 2); // 显式类型、无名称成员 (int index, Type type) entry = (first, null); // 显式类型、有名称成员  元组允许隐式转换：逐字段类型相同，且一方字段有名称而另一方无名称。\n类 类是引用类型（类似 C#、Swift、Java），概念上与结构体相似，但总是带有类型类指针，用于虚方法调用、动态类型和动态接口派发。所有用户类最终都继承自 System.Object。\nabstract class Shape { float x; float y; public abstract void Draw(); } class Circle : Shape { float radius; public override void Draw() { DrawCircle(x, y, radius); } /* 与结构体不同，修改类的成员方法不需要声明为 \u0026#39;mut\u0026#39; */ public void DoubleSize() { radius *= 2; } }  类可以定义析构函数，单个字段也可以定义字段析构函数，用于更紧密地将销毁与初始化关联起来。\n销毁顺序与构造相反。构造时，先构造基类，再按声明顺序执行字段构造，最后执行类构造函数。销毁时，先执行类析构函数，再按声明逆序执行字段析构，最后销毁基类。\npublic Button : Widget { String mLabel = new String() ~ delete _; // \u0026#34;_\u0026#34; 在此处是 \u0026#34;mLabel\u0026#34; 的别名  public ~this() { RemoveWidget(this); /* 字段析构在此之后执行，顺序与初始化相反 */ } }  数组 Beef 支持多种数组形式：数组类、定长数组类型、Span 以及原始指针。\n/* 分配 float 数组类 */ float[] floatArr = new float[3]; /* 分配二维 float 数组类 */ float[,] floatArr2D = new float[3, 2]; /* 这是定长数组，类似包含四个值的元组 */ float[4] sizedFloatArr = .(100, 200, 300, 400); int[?] inferredSizeArr = .(500, 600); let inferredSizeArr2 = int[?](700, 800, 900); /* Span 是指针/大小的值类型对 */ Span\u0026lt;float\u0026gt; floatSpan = floatArr; /* 原始指针。末尾的 \u0026#34;*\u0026#34; 表示原始数组分配而非 float[] 对象 */ float* floatPtr = new float[3]*;  枚举 Beef 的枚举类型可表示一组命名的整数常量。除非显式指定，枚举的底层类型将是能容纳所有指定值的最小整数类型。\nenum Direction { North, East, South, West } /* 注意无需写成 \u0026#34;Direction.South\u0026#34;，因为初始化器的期望类型是 \u0026#34;Direction\u0026#34;，因此已可推断 */ Direction facing = .South; /* 特殊值 \u0026#39;_\u0026#39; 会求值为上一个字段的值，便于定义位标志 */ enum MultiHue { Black = 0, Red = 1, Green = _*2, Blue = _*2 }  枚举也可使用更冗长的语法定义，以便像值类型结构体一样添加方法和属性。\nenum Direction { case North; case East; case South; case West; public Direction Opposite { get { switch (this) { case .North: return .South; case .East: return .West; case .South: return .North; case .West: return .East; } } } }  枚举提供一些操作以便检查和枚举其值。\n/* 从最小枚举值遍历到最大枚举值 */ for (var direction = typeof(Direction).MinValue; direction \u0026lt;= typeof(Direction).MaxValue; direction++) { } /* 转换为底层整数表示（此处为 int8） */ let val = direction.Underlying; /* 类似上面，但结果是可赋值的整数引用 */ let valRef = ref direction.UnderlyingRef;  枚举还可让多个值作为一组标志使用，支持类型安全的按位二元操作，并提供便捷的 \u0026ldquo;HasFlag\u0026rdquo; 方法用于检查是否设置了某组标志。\n枚举也可为每个 case 定义关联数据，使其表现为类型安全的“可辨识联合体”。\nenum Shape { case None; case Square(int x, int y, int width, int height); case Circle(int x, int y, int radius); } Shape drawShape = .Circle(10, 20, 5); ... switch (drawShape) { case .None: case .Square(let x, let y, let width, let height): DrawSquare(x, y, width, height); case .Circle(let x, let y, let radius): DrawCircle(x, y, radius); } .... if (drawShape case .Square) Console.WriteLine(\u0026#34;We drew a square\u0026#34;); if (drawShape not case .Square) Console.WriteLine(\u0026#34;We did not draw a square\u0026#34;); /* 若值不是 Circle，则 radius 仍保持 -1 */ int radius = -1; if (drawShape case .Circle(?, ?, ref radius)) {}  可空类型 可空类型是值类型的枚举包装（System.Nullable），使值类型能够使用通常只适用于指针与引用类型的 null 语义。\nint? val = null; int i = val ?? 21; if (val == null) val = 42; int? val2 = val + 123;  类型别名 Beef 的类型别名允许创建直接映射到另一个类型的类型名。\ntypealias Size = int; typealias Collection\u0026lt;T\u0026gt; = List\u0026lt;T\u0026gt;; typealias StringLookup = Dictionary\u0026lt;String, String\u0026gt;; "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/corlib/",
	"title": "核心库",
	"tags": [],
	"description": "",
	"content": " Beef 核心库概览 Beef 的基础标准库称为 \u0026ldquo;corlib\u0026rdquo;，提供基础工具类型与通用系统功能。\n以下为 corlib 提供的部分集合类型。\n   类别 类型     列表 System.Collections.List   字典 System.Collections.Dictionary   哈希集合 System.Collections.HashSet   队列 System.Collections.Queue    以下为 corlib 提供的部分功能，完整列表请参见 API 文档。\n   类别 类型     字符串 System.StringSystem.StringView   数学 System.Math   随机 System.Random   错误处理 System.Result   文件与目录 System.IO.FileSystem.IO.FileStreamSystem.IO.DirectorySystem.IO.Path   日期与时间 System.DateTime   计时 System.Diagnostics.Stopwatch   套接字 System.Net.Socket   线程 System.Threading.ThreadSystem.Threading.ThreadPoolSystem.Threading.MonitorSystem.Threading.WaitEvent   原子操作 System.Threading.Interlocked   控制台 System.Console   调试辅助 System.Diagnostics.Debug   哈希 System.Cryptography.MD5HashSystem.Cryptography.SHA256   文本编码 System.Text.Encoding   多播委托 System.Event   FFI System.FFI.FFILIBSystem.FFI.FFITypeSystem.FFI.FFICaller   Windows API System.Windows    多媒体库 Beef IDE 使用名为 Beefy2D 的窗口与多媒体库。该库仅供 IDE 与其他内部工具使用，不面向第三方应用，API 也可能在不保证向后兼容的情况下变更。因此第三方应用应使用其他第三方库。\n第三方多媒体库的一个例子是 SDL2，其用法可在随附的 Beef 示例中看到。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/interfaces/",
	"title": "接口",
	"tags": [],
	"description": "",
	"content": " 接口概览 接口定义了类或结构体需要实现的属性与方法要求。接口可用于动态派发，也可作为泛型约束使用（参见“泛型”部分）。\ninterface IDrawable { void Draw(); } struct Circle : IDrawable { float x; float y; float radius; /* Implements IDrawable.Draw If we wanted to keep the Draw method as a private implementation, we could have declared it as \u0026#34;private void IDrawable.Draw()\u0026#34; */ public void Draw() { DrawCircle(x, y, radius); } } /* Calling the following method with an instance of Circle will first cause boxing to occur at the callsite, then Draw will be called via dynamic dispatch (method table) */ public static void DrawDynamic(IDrawable val) { val.Draw(); } /* Calling the following method with an instance of Circle will create a specialized instance of the DrawGeneric method which accepts a Circle argument and statically calls the Circle.Draw method, which is faster */ public static void DrawGeneric\u0026lt;T\u0026gt;(T val) where T : IDrawable { val.Draw(); }  默认方法实现 接口可通过提供方法体来定义默认实现。这对于向既有接口添加方法而不破坏已有使用者非常重要。\n具体返回类型 接口方法可声明为返回某个接口的具体实现类型。由于未定义具体返回类型，此类方法无法用于动态派发。这有助于返回值类型实例，并避免动态方法派发——如果实现方法返回接口实例引用则必须动态派发。\nconcrete interface IEnumerable\u0026lt;T\u0026gt; { concrete IEnumerator\u0026lt;T\u0026gt; GetEnumerator(); } "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/projects/",
	"title": "项目与工作区",
	"tags": [],
	"description": "",
	"content": " 通用宏  $(BeefPath) - Beef 安装路径 $(Slash str) - 将输入字符串转换为斜杠路径 $(Var varName) - 变量 \u0026lsquo;varName\u0026rsquo; 的内容 $(VSToolPath) - Visual Studio 工具路径 $(VSToolPath_x64) - x64 的 Visual Studio 工具路径 $(VSToolPath_x86) - x86 的 Visual Studio 工具路径  工作区宏  $(Configuration) - 当前选中的构建配置 $(Platform) - 当前选中的构建平台 $(WorkspaceDir) - 工作区目录  项目宏  $(Arguments) - 调试时的命令行参数 $(BuildDir) - 构建目录，包含对象文件等构建产物 $(LinkFlags) - 默认链接参数 $(ProjectDir) - 包含该项目的目录 $(ProjectName) - 项目名称 $(TargetDir) - 目标二进制目录 $(TargetPath) - 该配置构建的目标二进制路径 $(WorkingDir) - 调试时的工作目录  项目宏可指定项目名，例如 \u0026ldquo;$(BuildDir LibA)\u0026ldquo;。\n预构建/后构建命令  CopyFilesIfNewer(srcPath, destPath) - 仅当源文件更新时复制文件（递归，支持通配符） CopyToDependents(srcPath) - 对依赖该库的项目，将这些文件复制到其目标目录 CreateFile(path, text) - 将 \u0026lsquo;text\u0026rsquo; 写入文件 \u0026lsquo;path\u0026rsquo; DeleteFile(path) - 删除文件 \u0026lsquo;path\u0026rsquo; DelTree(path) - 递归删除路径 Echo(text) - 将 \u0026lsquo;text\u0026rsquo; 输出到 Output 窗口或控制台 ReadFile(path, varName) - 读取文件 \u0026lsquo;path\u0026rsquo; 内容并赋值给变量 \u0026lsquo;varName\u0026rsquo; RenameFile(srcPath, destPath) - 重命名文件 \u0026lsquo;srcPath\u0026rsquo; 为 \u0026lsquo;destPath\u0026rsquo; SetVal(varName, value) - 设置变量 \u0026lsquo;varName\u0026rsquo; 为 \u0026lsquo;value\u0026rsquo; ShowFile(path) - 在 IDE 编辑器中打开 \u0026lsquo;path\u0026rsquo; Sleep(timeMS) - 延迟 timeMS 毫秒  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/platforms/",
	"title": "平台",
	"tags": [],
	"description": "",
	"content": " 一级平台： 以下平台名称被 Beef 原生识别，Beef 可作为这些平台的完整构建系统。这些平台之间不支持交叉编译，因为它们都需要访问系统原生的链接器与库。\n Win32 - Windows x86 Win64 - Windows x64 Linux32 - Linux x86 Linux64 - Linux x64 macOS - macOS x64  二级平台： 这些是由 LLVM 目标三元组表示的跨平台目标。在这些平台上，Beef 编译器由外部构建流程调用，生成可被外部构建流程链接进最终目标的 lib 文件。Beef 运行时需要事先为该平台编译好，并通过外部构建流程一并链接。\n iOS - (early alpha) Supported architectures include AArch64 and x64-based simulators. The Beef runtime can be built on macOS via bin/build_ios.sh. Android - (early alpha) Supported architectures include AArch64, ARM7, and x86/x64-based simulators. The Beef runtime can be built on Windows via bin/build_android.bat.  三级平台： 与二级平台类似，这些平台也由 LLVM 目标三元组表示，但没有内置的 Beef 运行时支持。尽管 Beef 编译器可以为这些架构生成机器码，但根据 corlib 的使用情况，运行时可能会缺少某些符号。此列表可轻松扩展为更多 LLVM 支持的目标，但相比扩展一级与二级平台，收益有限。\n arm7 - arm7-* aarch64 - aarch64-, arm64- x86 - x86-, i686- x64 - x86_64-*  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/statements/",
	"title": "语句",
	"tags": [],
	"description": "",
	"content": " break/continue 我们可以使用 \u0026ldquo;break\u0026rdquo; 终止执行 \u0026ldquo;for\u0026rdquo;、\u0026rdquo;while\u0026rdquo; 或 \u0026ldquo;do\u0026rdquo; 语句。使用 \u0026ldquo;continue\u0026rdquo; 可跳到 \u0026ldquo;for\u0026rdquo; 循环的下一次迭代；默认情况下，这些语句作用于当前作用域中最深层的适用语句，但可以使用标签引用更外层的语句。这在跳出嵌套循环等场景中很有用。\nY: for (int y \u0026lt; height) for (int x \u0026lt; width) if (Check(x, y)) break Y;  defer defer 语句用于将方法调用或代码块的执行推迟到退出某个作用域时。当延迟的是方法调用时，其参数（包括 this）会立刻求值。\n/* 以下将输出 \u0026#34;End:2 B:1 A:0\u0026#34;。注意执行顺序与 defer 的声明顺序相反。 */ { int i = 0; defer Console.WriteLine(\u0026#34;A:{}\u0026#34;, i); i++; defer Console.WriteLine(\u0026#34;B:{}\u0026#34;, i); i++; Console.WriteLine(\u0026#34;End:{}\u0026#34;, i); } /* 以下将输出 \u0026#34;End:2 B:2 A:2\u0026#34;。defer 位置没有参数需要求值，所以 WriteLine 使用的是作用域结束时的当前 i 值。 */ { int i = 0; defer { Console.WriteLine(\u0026#34;A:{}\u0026#34;, i); } i++; defer { Console.WriteLine(\u0026#34;B:{}\u0026#34;, i); } i++; Console.WriteLine(\u0026#34;End:{}\u0026#34;, i); } /* defer 语句可指定作用域目标。以下将在退出包含方法时打印 9 到 0。 */ { for (int i \u0026lt; 10) { defer:: Console.WriteLine(\u0026#34;i={}\u0026#34;, i); } } delete delete 语句释放已分配的内存。（参见 内存管理）\n delete x - 释放由全局分配器分配、由 x 引用的内存。 delete:a x - 释放由自定义分配器 a 分配的内存。  当 x 为对象时，会调用析构函数。\ndo 允许创建一个可被 break 跳出的非循环代码块，可在某些代码模式中减少 if 嵌套。\ndo { c = NextChar(); if (c == 0) break; op = NextChar(); if (c != \u0026#39;+\u0026#39;) break; c2 = NextChar(); }  for for 循环通常用于遍历集合或数列。可用形式如下。\n/* 经典 C 风格循环，包含初始化、条件和迭代器 */ for (int i = 0; i \u0026lt; count; i++) { } /* 上述形式的简写 */ for (int i \u0026lt; count) { } /* 遍历 List\u0026lt;int\u0026gt; 中的元素 */ for (let val in intList) { if (val == 0) @val.Remove(); } /* 上述等价于 */ var enumerator = intList.GetEnumerator(); while (enumerator.GetNext() case .Ok(let val)) { if (val == 0) enumerator.Remove(); } enumerator.Dispose(); /* 我们还可以按引用遍历而非按值遍历 */ for (var valRef in ref intList) valRef += 100; /* 常见错误：这不会改变 intList 的值，只会改变 enumerator.GetNext() 返回的值 */ for (var val in intList) val += 100;  if if (i \u0026gt; 0) Use(i); else if (i == 0) Use(1); else break; /* Some variable declarations can be used as a condition */ /* Use \u0026#39;not null\u0026#39; as a condition */ if (var str = obj as String) Console.WriteLine(str); /* Unwrap a Result\u0026lt;int\u0026gt; */ if (int i = intResult) Use(i); /* Unwrap an int? */ if ((int i = intNullable) \u0026amp;\u0026amp; (i != 0)) Use(i);  return 从方法返回一个值。\nint GetSize() { return mSize; }  repeat while 先执行一次语句，只要条件为真就继续重复执行。\nbool wantsMore; repeat { wantsMore = Write(); } while (wantsMore);  switch /* Note that \u0026#39;break\u0026#39; is not required after a case */ switch (c) { case \u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;: Space(); case \u0026#39;\\n\u0026#39; NewLine(); default: Other(); } switch (c) { /* Cases can contain additional \u0026#39;when\u0026#39; conditions */ case \u0026#39;\\n\u0026#39; when isLastChar: SendCommand(); case \u0026#39;A\u0026#39;: WasA(); /* \u0026#39;fallthrough\u0026#39; continues into the next case block*/ fallthrough; case \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;: WasVowel(); } switch (shape) { /* Pattern match, with \u0026#39;?\u0026#39; discard */ case .Circle(0, 0, ?): HandleOriginCircle(); case .Circle(let x, let y, let radius): HandleCircle(x, y, radius); default: }  Switches can be used for pattern matching (see for further examples) for enums and tuples.\n/* Note that switches over enums that do not handle every case and have no \u0026#39;default\u0026#39; case will give a \u0026#34;not exhaustive\u0026#34; compile error. Thus, if we added a new entry to the Shape definition, we would ensure that all switches will make modifications to handle it */ switch (shape) { case Square(let x, let y, let width, let height): DrawSquare(x, y, width, height); case Circle: IgnoreShape(); }  Switches can operate on non-integral types, as well.\nswitch (str) { case \u0026#34;TEST\u0026#34;: PerformTest(); case \u0026#34;EXIT\u0026#34;: Exit(); default: Fail(); }  using using 语句表示对值的作用域使用。\nusing (g.Open(\u0026#34;Header\u0026#34;)) { g.Write(\u0026#34;Hello\u0026#34;); } /* These are equivalent */ { var res = g.Open(\u0026#34;Header\u0026#34;); g.Write(\u0026#34;Hello\u0026#34;); res.Dispose(); } /* Or */ { defer g.Open(\u0026#34;Header\u0026#34;).Dispose(); g.Write(\u0026#34;Hello\u0026#34;); }  变量声明 // 定义可变变量，显式类型且不赋值 int val; // 定义多个变量，显式类型 int a, b; // 定义可变变量，显式类型并初始化 int val2 = 123; // 定义可变变量，隐式类型并初始化 var val3 = 1.2f; // 定义不可变变量，隐式类型并初始化 let val4 = 2.3;  while 当条件为真时重复执行语句。\nwhile (i \u0026gt;= 0) { i--; } "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/expressions/",
	"title": "表达式",
	"tags": [],
	"description": "",
	"content": " 分配 new 和 scope 关键字用于分配（参见 内存管理）\nappend append 表达式会在对象已分配内存的紧后位置继续分配，只能在构造函数中使用。（参见 内存管理）\nappend 分配可用于 new 分配能使用的任何场景。（参见 new）\n赋值操作 参见 赋值运算符\n二元操作 参见 二元运算符\n绑定表达式 =\u0026gt; =\u0026gt; 表达式用于方法绑定（参见 方法引用）\nbox box 表达式分配一个对象来包装值类型。（参见 内存管理（装箱））\n scope box x - 在当前作用域中装箱 x scope:s box x - 在作用域 s 中装箱 x new box x - 在全局分配器中装箱 x new:a box x - 在自定义分配器 a 中装箱 x\n  case case 表达式可在 switch 之外用于模式匹配。（参见 模式匹配）\n类型转换表达式  (T)x 将值 x 转换为类型 T  条件运算符  x ? y : z - 当 x 为 true 时结果为 y，否则为 z  条件变量声明 可空类型的变量声明可在 if 语句中用作布尔表达式。在某些二元操作中，当整体 if 条件为 true 能确保条件变量声明也被求值且结果为 true 时，这种写法是允许的。\n/* 简单的条件变量声明 */ if (let name = GetName()) { } /* “复杂”条件变量声明 */ if ((let name = GetName()) \u0026amp;\u0026amp; (isEnabled)) { } /* 这是非法的，因为 \u0026#34;force\u0026#34; 可能导致即使条件变量声明失败也进入该块 */ if ((let name == GetName()) || (force)) { }  default 每种类型都有一个 “default” 值，始终为零初始化。\n// Default 可指定类型并返回该类型的默认初始化值 var str = default(String); // 若未显式指定 default 类型，Default 会使用“期望类型” String str2 = default;  表达式块 表达式块以不带分号的表达式结尾。\nConsole.WriteLine(\u0026#34;Result={}\u0026#34;, { GetByRef(let val); val });  索引表达式  y = x[i] - 用索引 i 访问 x。若 x 为指针，则等价于 y = *(x + i)；否则调用 this[int] 索引器属性的 get 方法。 x[i] = y - 用索引 i 访问 x 并赋值。若 x 为指针，则等价于 *(x + i) = y；否则若 this[int] 索引器存在 set 方法则调用它，否则若 get 返回 ref 则调用 get 方法。  字面量  123 - 数字 0x1234 - 十六进制数字 0x1234'5678 - 带分隔符的数字，可放在任意位置 0x1234L - int64 十六进制数字 0x1234UL - uint64 十六进制数字 'c' - char8 '😃' - char32 1.2f - float 2.3 - double \u0026ldquo;Hello\u0026rdquo; - String  new new 表达式会在全局分配器或自定义分配器中分配内存。（参见 内存管理）\n new T(...) - 在全局分配器中分配 T 实例。若 T 为引用类型则结果为 T，否则结果为 T* new T[i] - 分配数组大小为 i 的 T[] new T[i] (...) - 分配数组大小为 i 的 T[] 并进行初始化 new T[] (...) - 分配 T[]，大小由初始化项数量决定 new T[i]* - 在全局分配器中分配 i 个连续的 T 实例，并返回指向首元素的 T* 指针。注意分配大小为 typeof(T).InstanceStride*i 以便使用，但严格来说这会在最后一个元素末尾分配额外填充。 new box x - 在全局分配器中装箱 x。（参见 内存管理（装箱））  所有 new 操作也可接受自定义分配器参数。\n new:a T(....) 在自定义分配器 a 中分配 T 实例，其中 a 为标识符。 new:(a) T(...) 在自定义分配器 a 中分配 T 实例，其中 a 可为任意表达式。  空条件运算符 空条件运算符 val?.field 和 val?[index] 在 val 为 null 时结果为 null。空条件运算符可链式使用，会在遇到第一个 null 时短路返回 null。\nint? a = val?.intField; int? nameLength = val?.name?.Length;  括号表达式 在表达式外加括号可改变复杂表达式的运算顺序。\nint a = 1 + 2 * 3; // The multiply happens before the add here, resulting in 7 int b = (1 + 2) * 3; // The add happens before the multiply here, resulting in 9  范围表达式 范围由起始与结束整数值组成，主要用于循环迭代和范围索引。可创建为包含式或排除式范围。索引范围可有一侧开放。（参见 范围运算符）\nlet list = scope List\u0026lt;int\u0026gt;() { 5, 1, 0 }; /* 由于在范围上迭代，创建范围时只会调用一次 list.Count */ /* 因此列表计数只是翻倍，而不会产生无限循环 */ for (let i in 0 ..\u0026lt; list.Count) list.Add(list[i]); // list 现在为：{ 5, 1, 0, 5, 1, 0 }  for (let i in (0 ..\u0026lt; list.Count).Reversed) list.Add(list[i]); // list 现在为：{ 5, 1, 0, 5, 1, 0, 0, 1, 5, 0, 1, 5 }  var subset = list[...2]; // 等价于 0...2、..\u0026lt;3 和 ...^10（^ 从末尾计数，起点为 Count） subset = list[4...]; // 等价于 4...11、4...^1 和 4..\u0026lt;^0  scope scope 表达式在栈上分配内存，作用域位于正在执行的方法之内。（参见 内存管理）\nscope 分配可用于 new 分配能使用的任何场景。（参见 new）\nthis this 是一个特殊变量名，表示实例方法中的当前实例。若定义类型为结构体，则 this 为值类型（非指针），在 \u0026ldquo;mut\u0026rdquo; 方法中可变，其他情况下不可变。\n元组表达式 元组表达式是一个括号包裹的表达式，包含多个逗号分隔的值，并可选字段名。（参见 数据类型（元组））\n一元操作 参见 一元运算符\n未初始化 \u0026lsquo;?\u0026rsquo; 当赋值给变量或字段时，? 会让该值被视为已赋值，但不一定执行任何实际操作。这在“缓冲区”类型数组等不需要在使用前清零的场景中很有用。\n在与 out 参数一起使用时，? 作为丢弃值。\n在构造函数中使用时，未初始化构造调用 this(...) : this(?) 与 this(...) : base(?) 会丢弃相应的初始化器与构造函数。参见 初始化。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/ide/",
	"title": "IDE",
	"tags": [],
	"description": "",
	"content": " 概览 Beef IDE 专为 Beef 开发而设计，同时包含通用调试器，适合调试任何语言编写的原生应用。\nIDE 功能  自动补全 重构工具：符号重命名、修复建议、转到定义、查找引用等 导航工具：类视图、成员下拉列表、在工作区打开文件、文件内搜索等 热代码修改 拼写检查 内置代码测试 代码格式化 程序自调试 API（如请求性能分析）  通用调试器功能  启动外部可执行文件或附加到现有进程 使用系统原生调试信息（如 Windows 的 PDB 文件） 加载 Windows minidump 支持符号服务器和源码服务器 支持内联调试信息（可正确查看内联方法的栈追踪、进入/跳出内联方法等） 调试可视化器（内置多种 C++ STL 类型的显示定义） 输入调试表达式时自动补全 使用步进过滤器跳过“不感兴趣”的函数 条件断点 内存断点 内存查看器 反汇编视图 性能分析器  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/beefbuild/",
	"title": "BeefBuild",
	"tags": [],
	"description": "",
	"content": " BeefBuild 概览 BeefBuild 是 Beef IDE 的命令行对应工具。\nBeefBuild -workspace=samples\\HelloWorld -run -args Argument1 Argument2     参数 说明     -args 在指定 \u0026lsquo;-run\u0026rsquo; 时，该参数后的内容会传给编译后的程序   -clean 构建时清理构建缓存   -config=\u0026lt;config\u0026gt; 设置构建配置   -generate 为一个空项目生成启动代码   -new 创建新的工作区和项目   -platform=\u0026lt;platform\u0026gt; 设置平台   -run= 编译并运行工作区中的启动项目   -test=\u0026lt;path\u0026gt; 执行测试脚本   -verbosity=\u0026lt;verbosity\u0026gt; 设置详细程度：quiet/minimal/normal/detailed/diagnostic   -workspace=\u0026lt;path\u0026gt; 设置工作区路径    "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/packman/",
	"title": "包管理器",
	"tags": [],
	"description": "",
	"content": " 包管理器概览 Beef 构建工具包含一个包管理器，可获取远程库依赖。在 IDE 中右键 “Workspace” 并选择 “Add Remote Project\u0026hellip;” 会弹出对话框，可输入远程 URL 与 Cargo 风格的 SemVer 版本约束。项目属性在 “Dependencies” 面板中包含 “Remote URL” 与 “Ver Constraint” 区域，允许库指定其版本约束。当工作区中同一库出现多个冲突的版本约束时，包管理器会选择满足最多约束条件的最高可用版本。\n当项目使用远程库时，会生成 BeefSpace_Lock.toml 文件，用于将工作区锁定到当前远程的最佳版本匹配。在 IDE 中右键 “Workspace” 并选择 “Update Version Locks” 可更新工作区内的所有版本锁定。\n如果远程项目包含名为 “Setup” 的目录，包管理器会构建并运行该目录中的工作区。该程序可执行库的任何初始化操作，包括下载或构建额外的二进制库依赖。\n版本约束 1.2.3 := \u0026gt;=1.2.3, \u0026lt;2.0.0 1.2 := \u0026gt;=1.2.0, \u0026lt;2.0.0 1 := \u0026gt;=1.0.0, \u0026lt;2.0.0 0.2.3 := \u0026gt;=0.2.3, \u0026lt;0.3.0 0.2 := \u0026gt;=0.2.0, \u0026lt;0.3.0 0.0.3 := \u0026gt;=0.0.3, \u0026lt;0.0.4 0.0 := \u0026gt;=0.0.0, \u0026lt;0.1.0 0 := \u0026gt;=0.0.0, \u0026lt;1.0.0 ~1.2.3 := \u0026gt;=1.2.3, \u0026lt;1.3.0 ~1.2 := \u0026gt;=1.2.0, \u0026lt;1.3.0 ~1 := \u0026gt;=1.0.0, \u0026lt;2.0.0 * := \u0026gt;=0.0.0 1.* := \u0026gt;=1.0.0, \u0026lt;2.0.0 1.2.* := \u0026gt;=1.2.0, \u0026lt;1.3.0 \u0026gt;= 1.2.0 \u0026gt; 1 \u0026lt; 2 = 1.2.3"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/interop/",
	"title": "互操作",
	"tags": [],
	"description": "",
	"content": " 互操作（FFI） Beef 允许零开销地链接静态与动态库。声明为 extern 的方法会创建外部符号引用，必须在链接时被满足。当缺少 C 链接库时，Beef 也可通过 [Import(...)] 特性导入 DLL 方法。默认的符号重整规则类似于 C++，在许多情况下可匹配，但可通过 [CLink] 或 [LinkName] 覆盖方法的链接名。\n/* 链接外部库中的方法，使用以下特性： Import：使用该方法时链接 \u0026#39;wsock32.lib\u0026#39; 库 CLink：不使用 C++ 重整，改用 C 链接名 StdCall：使用 stdcall 调用约定（WINAPI） */[Import(\u0026#34;wsock32.lib\u0026#34;), CLink, StdCall] static extern int32 WSAGetLastError(); /* 该方法链接到 C++ 中定义为 \u0026#39;const float\u0026amp; GetVal(const int32\u0026amp; a)\u0026#39;\u0026#39; 的外部函数 */[return: MangleConst, LinkName(.CPP)] public static extern ref float GetVal([MangleConst]ref int32 a);  由于字段重排（减少对齐空隙）以及 Beef 将结构体大小与步长分离（Beef 结构体末尾不包含对齐填充），默认情况下结构体布局并不与 C 的结构体布局一致。可使用 [CRepr] 特性创建与 C 匹配的结构体以便互操作。\n默认情况下 Beef 使用系统的 cdecl 调用约定，除非方法标记为 [StdCall]，此时使用系统的 stdcall 约定。\n若 FFI 需要 CRT 分配器，请注意工作区可定义全局分配器，因此可能无法使用 CRT 的分配器。此时可通过 System.Internal.StdMalloc 和 System.Internal.StdFree 管理 FFI 内存，或使用 System.gCRTAlloc 自定义分配器。\nBeef 也支持通过 corlib 的 System.FFI 进行手动与动态外部函数接口（FFI）。\n互操作类型映射    C/C++ System.Interop TypeAlias Beef Primitive     short c_short int16   unsigned short c_ushort uint16   int c_int int32   unsigned int c_uint uint32   long (Windows) c_long int32   long (Linux/macOS/others) c_long int64   unsigned long (Windows) c_ulong uint32   unsigned long (Linux/macOS/others) c_ulong uint64   long long c_longlong int64   unsigned long long c_ulonglong int64   intptr_t c_intptr int   uintptr_t c_uintptr uint   char c_char char8   unsigned char c_uchar uint8   wchar_t (Windows) c_wchar char16   wchar_t (Linux/macOS/others) c_wchar char32    ABI 稳定性 Beef 不提供通用 ABI 稳定性，除了由通用的 FFI C 互操作带来的那部分——即便是完全相同代码的独立编译，也不保证生成稳定的 ABI 边界。以下是一些可能在 ABI 边界库未改动代码时仍会出现的 ABI 破坏例子：\n 工作区调试设置会影响对象的大小与内容。这些设置包括 “Object Debug Flags”、“Realtime Leak Check”、“Enable Hot Compilation”、“Large Strings” 和 “Large Collections”。 用户程序与库可添加类型扩展，改变系统类型的数据布局 快速动态转换依赖生成工作区范围的继承顺序类型 ID 去虚拟化可能发生，并依赖调用点对完整继承信息的了解 反射数据在 ABI 边界之间不兼容 字符串字面量地址相等保证会被破坏 按需编译也会影响 vtable 布局，因为被省略的方法不会占用 vtable 项 全局分配器的选择发生在工作区级别  尽管 C++ 等语言并未“官方”提供稳定 ABI，其独立“编译模块”的方式有时可形成一种“软”ABI：只要能保证边界两侧（库与库使用者）以“兼容设置”编译，包括编译器版本、兼容头文件、相关预处理器标志、谨慎的内存管理等，便可形成可用的 ABI 边界。虽然这比 Beef 的 ABI 稳定性稍强，但仍不足以满足 ABI 稳定性的总体目标——包括允许库作者发布包含安全或性能改进的二进制库更新而无需用户程序重新编译，以及提供系统级库使其二进制足迹无需随用户程序一并打包（这也是 Swift ABI 稳定性的主要目标之一）。\n进一步阅读：https://gankra.github.io/blah/swift-abi/\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/generics/",
	"title": "泛型",
	"tags": [],
	"description": "",
	"content": " 泛型概览 泛型允许在编译期编写可应用于不同类型的抽象代码。例如 List 是一个基础列表抽象，可安全地存储不同类型的值。使用 \u0026ldquo;List\u0026rdquo; 类型引用会创建特化的 int32 列表类型。\n方法也可以拥有泛型参数，从而根据调用点的参数类型进行显式或隐式特化。\npublic static T GetFirst\u0026lt;T\u0026gt;(List\u0026lt;T\u0026gt; list) { return list[0]; } ... let intList = new List\u0026lt;int32\u0026gt;(); intList.Add(123); let firstVal = GetFirst(intList);  可指定泛型约束，用于描述泛型代码所期望的类型“形状”。\n 接口类型 - 可为泛型参数指定任意数量的接口，传入类型必须实现这些接口。 类/结构体类型 - 可指定一个具体类型，传入类型必须从其派生。 委托类型 - 传入类型可为该委托类型实例，或为签名符合该委托的方法引用（参见方法引用）。 operator T \u0026lt;op\u0026gt; T2 - 类型必须由指定类型间的二元运算得到 operator \u0026lt;op\u0026gt; T - 类型必须由指定类型的一元运算得到 operator implicit T - 类型必须可从指定类型隐式转换得到 operator explicit T - 类型必须可从指定类型显式转换得到 class - 类型必须为类 struct - 类型必须为值类型 enum - 类型必须为枚举 interface - 类型必须为接口 struct* - 类型必须为值类型指针 new - 类型必须定义可访问的默认构造函数 delete - 类型必须定义可访问的析构函数 const - 类型必须为常量值 - 参见“常量泛型” var - 类型不受约束。对某些“鸭子类型”场景有用，可生成类似 C++ 模板的模式，但通常会产生不够友好的错误与较差的开发体验  public static T Abs\u0026lt;T\u0026gt;(T value) where T : IOpComparable, IOpNegatable { if (value \u0026lt; default) return -value; else return value; } /* This method can eliminate runtime branching by specializing at compile time by incoming array size */ public static float GetSum\u0026lt;TCount\u0026gt;(float[TCount] vals) where TCount : const int { if (vals.Count == 0) { return 0; } else if (vals.Count == 1) { return vals[0]; } else { float total = 0; for (let val in vals) total += val; return total; } } static TTo Convert\u0026lt;TTo, TFrom\u0026gt;(TFrom val) where TTo : operator explicit TFrom { return (TTo)val; } /* We use partial explicit generic args to allow inference of \u0026#39;TFrom\u0026#39; */ var val = Convert\u0026lt;int...\u0026gt;(1.2f);  支持泛型构造函数。\nclass WriteValue { public this\u0026lt;T\u0026gt;(T val) { Console.WriteLine($\u0026#34;Value: {val}\u0026#34;); } } /* Implicitly determine \u0026#39;T\u0026#39; for constructor */ var val = scope WriteVal(1.0f); /* Explicitly specify \u0026#39;T\u0026#39; for constructor */ var val = scope WriteVal.this\u0026lt;float\u0026gt;(1); "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/reflection/",
	"title": "反射",
	"tags": [],
	"description": "",
	"content": " 反射 Beef 支持运行时反射，可枚举并访问类型、字段、方法和属性。默认情况下，为了减小可执行文件，仅包含最少的反射信息。可以通过代码特性标注需要额外输出的类成员信息。\npublic struct Options {[Reflect] public bool mFlag; } void Use(ref Options options) { /* 注意此处使用 \u0026amp;options，以装箱指向 \u0026#39;options\u0026#39; 的指针，而不是装箱 \u0026#39;options\u0026#39; 的副本 */ options.GetType().GetField(\u0026#34;mFlag\u0026#34;).Value.SetValue(\u0026amp;options, true); }  反射构造 可以通过反射信息创建值。需要确保相关类型确实被包含在构建产物中。\n/* 由于我们仅通过反射实例化该类型，需要强制包含所需数据 */ /* 如果在已包含的代码中创建 TestClass 实例，则此处不一定需要 AlwaysInclude 特性 */[Reflect(.DefaultConstructor), AlwaysInclude(AssumeInstantiated=true)] class TestClass { } void DynamicCreate() { /* CreateObject() 返回 Result\u0026lt;Object\u0026gt;，可这样处理 */ if (Object obj = typeof(TestClass).CreateObject()) { Console.WriteLine(\u0026#34;Successfully created TestClass instance\u0026#34;); UseObject(obj); /* 通过反射创建的对象和值在堆上分配，需要 delete */ delete obj; } }  反射自定义特性 /* 该特性会出现在用户的反射信息中，使用该特性的类型会导出其使用的方法的反射信息 */[AttributeUsage(.Class | .Struct, .ReflectAttribute, ReflectUser=.Methods)] struct ScriptableAttribute : Attribute { public String mName; public this(String name) { mName = name; } } /* 该类将提供可反射的默认构造函数，且所有方法都会被包含在构建中，即使它们未被直接调用 */[Scriptable(\u0026#34;Main Test Class\u0026#34;), AlwaysInclude(AssumeInstantiated=true, IncludeAllMethods=true)] class TestClass { public static void Test() { Console.WriteLine(\u0026#34;TestClass.Test\u0026#34;); } } class Program { public static void Main() { for (let type in Type.Types) { if (let scriptableAttribute = type.GetCustomAttribute\u0026lt;ScriptableAttribute\u0026gt;()) { for (let method in type.GetMethods(.Static)) { Console.WriteLine(\u0026#34;Calling method {} on {}\u0026#34;, method.Name, scriptableAttribute.mName); method.Invoke(null); } } } } }  或者也可以把 AlwaysInclude 的效果直接写到 Scriptable 特性上。使用下列结构体时，TestClass 只需要标注 Scriptable 特性即可。\n[AttributeUsage(.Class | .Struct, .ReflectAttribute, ReflectUser=.Methods, AlwaysIncludeUser=.AssumeInstantiated | .IncludeAllMethods)] struct ScriptableAttribute : Attribute { public String mName; public this(String name) { mName = name; } }  调用反射方法 [AlwaysInclude(IncludeAllMethods=true), Reflect(.Methods)] class MethodHolder { public int mIdentifier; static int GiveMeFive() { return 5; } public static void Print(int num, String message) { Console.WriteLine(scope $\u0026#34;{num}: {message}\u0026#34;); } public void ChangeIdentifier(int newIdent) { mIdentifier = newIdent; Console.WriteLine(scope $\u0026#34;I am now number {newIdent}\u0026#34;); } } class Program { static void InvokeFuncs() { /* 调用成员方法 */ { let mh = scope MethodHolder(); /* 将 \u0026#39;mh\u0026#39; 作为 target，并传入方法参数。注意此处未处理错误 */ typeof(MethodHolder).GetMethod(\u0026#34;ChangeIdentifier\u0026#34;).Get().Invoke(mh, 14); Runtime.Assert(mh.mIdentifier == 14); } /* 调用所有静态方法 */ int passInt = 8; for (let m in typeof(MethodHolder).GetMethods(.Static)) PARAMS: { /* 根据函数参数传入参数 */ let methodParams = scope Object[m.ParamCount]; for (let i \u0026lt; m.ParamCount) { Object param; switch (m.GetParamType(i)) /* 覆盖此示例中的所有情况 */ { case typeof(String): param = \u0026#34;A nice string message\u0026#34;; case typeof(int): /* 需要手动装箱，确保调用方法时不会因离开作用域而被释放 */ /* param = passInt; 会隐式装箱 passInt，但会在离开 \u0026#39;for (let i \u0026lt; m.ParamCount)\u0026#39; 循环后被删除 */ /* 而我们需要其在外层 \u0026#34;method\u0026#34; 循环的周期内保持有效，以便 Invoke() 调用 */ param = scope:PARAMS box passInt; default: param = null; } methodParams[i] = param; } /* 调用方法并处理结果/返回值。静态方法没有 target */ /* 注意 \u0026#39;Invoke(null, methodParams)\u0026#39; 会将 Object[] 作为唯一参数传入 */ switch (m.Invoke(null, params methodParams)) { case .Ok(let val): /* 处理返回的 int variant */ if (val.VariantType == typeof(int)) { let num = val.Get\u0026lt;int\u0026gt;(); Console.WriteLine(scope $\u0026#34;Method {m.Name} returned {num}\u0026#34;); } case .Err: Console.WriteLine(scope $\u0026#34;无法调用方法 {m.Name}\u0026#34;); } } } } /* 输出： I am now number 14 Method GiveMeFive returned 5 8: A nice string message */  从接口反射 /* 实现该接口的所有类型都会启用动态装箱 */[Reflect(.None, ReflectImplementer=.DynamicBoxing)] interface ISerializable { void Serialize(Stream stream); } namespace System { extension StringView : ISerializable { void ISerializable.Serialize(Stream stream) { stream.Write(mLength); stream.TryWrite(.((uint8*)mPtr, mLength)); } } } class Serializer { public void Serialize(Variant v, Stream stream) { ISerializable iSerializable; if (v.IsObject) iSerializable = v.Get\u0026lt;Object\u0026gt;() as ISerializable; else { /* 由于 \u0026#39;ReflectImplementer=.DynamicBoxing\u0026#39; 特性，\u0026#39;v.GetBoxed\u0026#39; 可用于实现 ISerializable 的类型 */ iSerializable = v.GetBoxed().GetValueOrDefault() as ISerializable; defer:: delete iSerializable; } iSerializable?.Serialize(stream); } }  编译期类型枚举 在编译期通过 Type.Types 枚举类型是不允许的，因为在编译完全结束之前无法得知所有类型的集合。不过可以在编译期枚举工作区的类型*声明*。类型声明不包含泛型实例、数组、元组、可空类型或其他按需类型，也不包含只有在类型闭合后才知道的信息（如大小或成员列表）。类型声明仅在编译期可用，运行时不可用。\n[Comptime] int GetSerializableCount() { int count = 0; for (var typeDecl in Type.TypeDeclarations) { if (typeDecl.HasCustomAttribute\u0026lt;SerializableAttribute\u0026gt;()) count++; } return count; }  Distinct Build Options 反射信息可在工作区与项目的 Distinct Build Options 中配置。例如，如果你需要为所有 System.Collection.List\u0026lt;T\u0026gt; 实例反射 Add 与 Remove 方法，可以在 Distinct Build Options 下添加 System.Collections.List\u0026lt;*\u0026gt;： * 将 \u0026ldquo;Reflect\\Method Filter\u0026rdquo; 设为 \u0026ldquo;Add;Remove\u0026rdquo;，确保设置仅应用于这些方法 * 将 \u0026ldquo;Reflect\\Always Include\u0026rdquo; 设为 \u0026ldquo;Include All\u0026rdquo;，确保指定方法即使未被显式使用也会编译进构建 * 将 \u0026ldquo;Reflect\\Non-Static Methods\u0026rdquo; 设为 \u0026ldquo;Yes\u0026rdquo;，确保指定的非静态方法添加反射信息\nDistinct Build Options 过滤器支持： * 类型名匹配（如 System.Collections.List\u0026lt;*\u0026gt;） * 类型特性匹配（如 [System.Optimize]） * 接口实现匹配（如 :System.IDisposable）\n动态装箱 Variant.GetBoxed 可用于动态创建堆分配的装箱对象。如果编译器未通过按需编译或反射选项生成存储值类型的盒类型（如为值类型标注 [Reflect(.DynamicBoxing)] 或在 Distinct Build Options 中设置 \u0026ldquo;Dynamic Boxing\u0026rdquo;），则调用会失败。\n常见反射问题 Beef 致力于生成尽可能小的可执行文件——一个 “Hello World” 程序理想情况下只应包含打印 “Hello World” 所需的最小机器码和数据。如果你为该程序增加功能，让用户传入类型名与方法名，并期望基于反射信息构造该类型并调用该方法，那么除非可执行文件包含 corlib 中每个方法的机器码和反射信息，否则显然无法实现，这将违背“最小二进制”的目标。\n首先，Beef 按需包含类型，因此未被程序直接使用的类型不会包含在构建中。可添加 [AlwaysInclude] 特性强制在所有构建中包含该类型。如果需要动态构造该类型，使用 [AlwaysInclude(AssumeInstantiated=true)]。单个方法也会按需编译，但可通过 [AlwaysInclude(IncludeAllMethods=true)] 强制将所有方法编译进构建。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/literals/",
	"title": "字面量",
	"tags": [],
	"description": "",
	"content": " 整数字面量 整数可以用十进制、十六进制、八进制或二进制表示。此外，分隔符字符 '（单引号）可按需要分隔数字。\n// Decimal numbers int dec = 1234; int dec2 = 12\u0026#39;345\u0026#39;678; // Hexadecimal int hex = 0x12345678; int hex2 = 0x1235\u0026#39;5678; // Octal int oct = 0o666; // Binary uint32 bin = 0b\u0026#39;1111\u0026#39;0000\u0026#39;1111\u0026#39;0000;  可通过后缀显式指定大小与有符号性。除非使用大小后缀或至少包含一个分隔符字符，否则整数字面量默认限制为 32 位。\nlet val = 123U; // Results in an \u0026#39;uint\u0026#39; let val2 = 234L; // Results in an \u0026#39;int64\u0026#39; let val3 = 0x12\u0026#39;34567890; // Results in an `int64` let val4 = 0x1234567890; // ERROR- either an \u0026#39;L\u0026#39; or \u0026#39;`\u0026#39; is required  当未使用大小后缀时，整数字面量本身没有固定大小，其大小取决于使用上下文：\n 整数字面量可隐式转换为任何可容纳该值的整数类型。 作为重载方法的参数时，会选择可适用的最小整数类型的方法。 若无法确定具体整数类型，则依次使用能容纳该值的第一个类型：int、uint、int64、uint64。  浮点数字面量 浮点数字面量默认为 double，除非以 f 结尾。\nlet f = 1.2f; // Float let d = 2.3; // Double  布尔字面量 布尔字面量为 true 或 false。\n字符串字面量 字符串可为单行或多行，也可为原始或转义字符串。原始字符串允许直接包含反斜杠字符，而不会被解释为“特殊字符”序列的起始。\nString str = \u0026#34;Normal string\u0026#34;; String str2 = @\u0026#34;Raw string with \\ slashes\u0026#34;; String str3 = \u0026#34;\u0026#34;\u0026#34; \tMultiline string literal with a tabbed second line; \u0026#34;\u0026#34;\u0026#34;; String str4 = @\u0026#34;\u0026#34;\u0026#34; Multiline raw string literal with embedded \\slashes\\; \u0026#34;\u0026#34;\u0026#34;; String str = scope $$\u0026#34;\u0026#34;\u0026#34; /* The \u0026#39;$$\u0026#39; means embedded values need to be wrapped with {{ }}, allowing us to not escape { and } for normal text. */ /* If we used `$$$` then values would need {{{ }}} */ void SetDefault() { {{fieldName}} = default; } \u0026#34;\u0026#34;\u0026#34;;  字符字面量 字符字面量可为 char8 或 char32，取决于其数值。\nlet c = \u0026#39;A\u0026#39;; //char8 let c = \u0026#39;🐱\u0026#39;; //char32  字符串与字符字面量中的特殊字符  \\0 - 空字符 \\\\ - 反斜杠 \\u{n} - Unicode 字符 \\xNN - 十六进制字符 0xNN \\t - 水平制表符 \\n - 换行符 \\r - 回车符 \\\u0026rdquo; - 双引号 \\\u0026rsquo; - 单引号  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/pattern/",
	"title": "模式匹配",
	"tags": [],
	"description": "",
	"content": " 模式匹配概览 模式匹配既可用于简单的相等性检查，也可在 switch 与 case 表达式中对元组和枚举值组合使用成员相等检查、成员捕获与成员“忽略”。\n元组模式匹配 void TupleCaseExpr() { let tup = (1.2, \u0026#34;Abc\u0026#34;); // This performs one equality check and one member capture \tif (tup case (1.2, let str)) { UseStr(str); } } void TupleSwitch() { let tup = (x: 10, y: 20, str:\u0026#34;Abc\u0026#34;); switch (tup) { case (0, 0, let drawStr): DrawAtOrigin(drawStr); case (var drawX, var drawY, let drawStr): /* Since drawX and drawY are \u0026#39;var\u0026#39; the are mutable, whereas drawStr is immutable */ drawX += 10; drawY += 20; Draw(x, y, drawStr); } }  枚举模式匹配 enum Shape { case Rectangle(int x, int y, int width, int height); case Circle(int x, int y, int radius); } void EnumCase() { Shape shape = .Circle(10, 20, 30); /* One enum discriminator check, two member equality checks, and one member captures */ if (shape case .Circle(0, 0, let radius)) { DrawCircleAtOrigin(radius); } /* One enum discriminator check, and three member captures */ else if (shape case .Circle(let x, let y, let radius)) { DrawCircle(x, y, radius); } /* One enum discriminator check, and two member captures, one member ignore */ else if (shape case .Circle(let x, let y, ?)) { DrawPoint(x, y); } /* Enum discriminator check, no member checks or captures*/ if (shape case .Rectangle) { IgnoreRectangle(); } } /* This is equivalent to the EnumCase method */ void EnumSwitch() { Shape shape = .Circle(10, 20, 30); switch (shape) { case .Circle(0, 0, let radius): DrawCircleAtOrigin(radius); case .Circle(let x, let y, let radius): DrawCircle(x, y, radius); case .Rectangle: IgnoreRectangle(); } }  枚举也可以匹配到 ref，从而修改其内部值。\nvoid Enlarge(ref Shape shape) { switch (shape) { case .Circle(?, ?, var ref radius): radius++; case .Rectangle(?, ?, var ref width, var ref height): width++; height++; } } "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/operators/",
	"title": "运算符",
	"tags": [],
	"description": "",
	"content": " 运算符概览 以下运算符分组按优先级从高到低排列。\n主运算符  x.y - 成员访问 x..y(\u0026lt;method args\u0026gt;) - 成员访问级联。将方法 y 的结果替换为 x，用于将多个方法调用串联到同一目标上。例如：string..Append(\u0026quot;name: \u0026quot;).Append(name); 尽管 Append 返回 void，但两个 Append 都作用于 string。 x?.y - 空条件成员访问。若 x 为 null，则结果为 null。 f(x) - 方法调用 a[x] - 数组索引  一元运算符  x++ - 后缀自增，先返回自增前结果再递增 x x-- - 后缀自减，先返回自减前结果再递减 x ++x - 前缀自增，先递增 x 再返回新值 --x - 前缀自减，先递减 x 再返回新值 ~x - 按位取反 !x - 逻辑取反 (T)x - 将 x 转换为类型 T \u0026amp;x - 取 x 的地址 *x - 解引用指针 x x(..y, \u0026lt;other method args\u0026gt;) - 参数级联。将方法 x 的结果替换为 y，用于复用参数。例如参见 字符串易用性。  乘除运算符  x * y - 乘法 x \u0026amp;* y - 禁用溢出检查的乘法 x / y - 除法。若 x 与 y 为整数，则结果为向零截断的整数。 x % y - 取余。若 x 与 y 为整数，则结果为 x / y 的余数。  加减运算符  x + y - 加法 x \u0026amp;+ y - 禁用溢出检查的加法 x - y - 减法 x \u0026amp;- y - 禁用溢出检查的减法。允许两个无符号整数相减而不产生有符号整数。  移位运算符  x \u0026lt;\u0026lt; y - 左移 x \u0026gt;\u0026gt; y - 右移。若 x 为有符号数，则左侧用符号位填充。  太空船运算符  x \u0026lt;=\u0026gt; y - 若 x \u0026lt; y 返回负数，x == y 返回 0，x \u0026gt; y 返回正数  比较运算符  x \u0026lt; y x \u0026gt; y x \u0026lt;= y x \u0026gt;= y x is T - 若 x 可转换为类型 T 则结果为 true x as T - 若可转换则将 x 转为 T，否则结果为 null  逻辑 AND 运算符  x \u0026amp; y - 按位 AND  逻辑 XOR 运算符  x ^ y - 按位 XOR  逻辑 OR 运算符  x | y - 按位 OR  相等运算符  x == y x === y - 严格相等 x != y x !== y - 严格不等  严格相等运算符可用于检查引用相等，跳过所有相等运算符重载。对于结构体或元组等值类型，严格相等会执行逐成员的严格相等检查。\n条件 AND 运算符  x \u0026amp;\u0026amp; y  条件 OR 运算符  x || y  空合并运算符  x ?? y - 若 x 非空则结果为 x，否则为 y  条件运算符  x ? y : z - 当 x 为 true 时结果为 y，否则为 z  赋值运算符 赋值结果为 x 的新值。\n x = y x += y x -= y x *= y x /= y x %= y x |= y x ^= y x \u0026lt;\u0026lt;= y x \u0026gt;\u0026gt;= y x ??= y =\u0026gt; x - 方法绑定运算符  类型属性运算符  sizeof(T) - T 的大小。注意引用类型总是返回原生指针大小 alignof(T) - T 的对齐 strideof(T) - T 的步长（按 T 的对齐方式对齐） alloctype(T) - new T() 的结果，若 T 为引用类型则为 T，若为值类型则为 T* comptype(x) - 反射类型 x 的类型 decltype(x) - 表达式 x 的结果类型。允许任意表达式（包括方法调用），但仅用于确定类型，不生成可执行代码。 nullable(T) - 若 T 已是可空类型则为 T，否则为 T? rettype(T) - 委托或函数的返回类型 typeof(T) - T 的反射类型 offsetof(T, field) - field 在 T 中的字节偏移 nameof(T, field) - field 在 T 中的名称  引用运算符  ref x - 传入 ref 参数或需要 ref 的值时必需 out x - 传入 out 参数时必需 var x - 从 out 参数创建新变量 x let x - 从 out 参数创建新常量/只读变量 x  Params 运算符  params x - 当 x 为可变参数时，将这些参数传递给另一个可变参数。当 x 为委托或函数的 params 时，会在原地展开。  示例参见 可变参数数量。\n范围运算符  x...y - 创建包含式范围，从 x 到 y（含 y） x..\u0026lt;y - 创建排除式范围，从 x 到 y（不含 y）\n x... - 创建索引范围，从 x 到集合末尾（含末尾）\n ...y - 创建索引范围，从集合起始到 y（含 y）\n x...^y - 创建索引范围，从 x 到 y（含 y），但 y 从末尾计数（见下方 Index 运算符）。例如从列表第 x 个元素到从后往前数的第 y 个元素。\n  示例参见 范围表达式。\n末尾索引运算符  ^x - 创建一个从末尾计数的 Index（.FromEnd），其中最后一个元素为 ^1（^0 等于集合的数量/长度）  Index 主要用于集合索引与范围构造。\nlet list = scope List\u0026lt;int\u0026gt;() { 5, 1, 0 }; let first = list[0]; // first == 5  // 从末尾索引起点是 Count（此处为 3），超出范围，因此向前一位得到最后元素 -\u0026gt; ^1 let last = list[^1]; // last == 0  类型转换 (T)x 类型转换运算符可直接执行多种类型转换，但有一些特殊情况： * 反装箱。(T)obj 其中 obj 为 Object、T 为值类型，会执行反装箱。该反装箱在 Debug 模式下（启用动态转换检查时）可能在运行时失败。可使用 obj is T 检查或 obj as T? 表达式安全反装箱。 * 获取对象地址：(void*)obj（obj 为 Object 类型）实际上是反装箱请求，而非类型转换。System.Internal.UnsafeCastToPtr 可返回 Object 的地址作为 void*。 * 转换为不相关类型。有时可使用双重转换实现原本非法的转换。例如 (void*)handle 中 handle 是带类型的基础类型 struct Handle : int，直接转为 void* 不允许，但 (void*)(int)handle 允许。\n运算符重载 结构体与类可提供运算符重载。比较运算符的选择较灵活，不需要定义 \u0026lt;、\u0026lt;=、==、!=、\u0026gt;、\u0026gt;= 的全部组合。若存在“逆运算符”，会优先调用；或仅定义 \u0026lt;=\u0026gt; 运算符时，也可用于所有比较类型。\nstruct Vector2 { float x; float y; public this(float x, float y) { this.x = x; this.y = y; } /* 二元 + 运算符 */ public static Vector2 operator+(Vector2 lhs, Vector2 rhs) { return .(lhs.x + rhs.x, lhs.y + rhs.y); } /* 一元 \u0026#39;-\u0026#39; 运算符 */ public static Vector2 operator-(Vector2 val) { return .(-val.x, -val.y); } /* 一元 \u0026#39;++\u0026#39; 运算符 */ public static Vector2 operator++(Vector2 val) { return .(val.x + 1, val.y + 1); } /* 非静态一元 \u0026#39;--\u0026#39; 运算符 */ public void operator--() mut { x--; y--; } /* 赋值 \u0026#39;+=\u0026#39; 运算符 */ public void operator+=(Vector2 rhs) mut { x += rhs.x; y += rhs.y; } /* 比较运算符 */ public static int operator\u0026lt;=\u0026gt;(Vector2 lhs, Vector2 rhs) { /* 先比较 X，若 X 相等则比较 Y */ int cmp = lhs.x \u0026lt;=\u0026gt; rhs.x; if (cmp != 0) return cmp; return lhs.y \u0026lt;=\u0026gt; rhs.y; } /* 来自 float[2] 的转换运算符 */ public static operator Vector2(float[2] val) { return .(val[0], val[1]); } }  二元运算符可标记为 [Commutable] 特性，从而允许某些运算符变换。例如，可交换的 \u0026ldquo;A \u0026lt; B\u0026rdquo; 运算符可用于 \u0026ldquo;B \u0026gt; A\u0026rdquo;、\u0026rdquo;!(A \u0026gt;= B)\u0026rdquo; 和 \u0026ldquo;!(B \u0026lt;= A)\u0026ldquo;。可交换的 \u0026ldquo;A == B\u0026rdquo; 运算符可用于 \u0026ldquo;B == A\u0026rdquo;、\u0026rdquo;!(A != B)\u0026rdquo; 与 \u0026ldquo;!(B != A)\u0026ldquo;。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/errors/",
	"title": "错误处理",
	"tags": [],
	"description": "",
	"content": " 错误处理 一些语言如 C# 使用异常处理，但 Beef 不支持异常。按照约定，错误处理使用 System.Result 和 System.Result枚举类型，它们包含 .Ok(T) 与 .Err(TError) 两个值。带 TError 参数的版本支持返回显式错误值，否则错误类型未指定。泛型可用 \u0026ldquo;void\u0026rdquo; 作为参数，因此 Result 用于可能返回错误但没有返回值的方法。\n若未处理返回的错误，将导致运行时致命错误。\nstatic Result\u0026lt;uint\u0026gt; GetMinusOne(uint i) { if (i == 0) return .Err; return .Ok(i - 1); } void Use() { /* Handle result via a switch */ switch (GetMinusOne(i)) { case .Ok(let newVal): Console.WriteLine(\u0026#34;Val: {}\u0026#34;, newVal); case .Err: Console.WriteLine(\u0026#34;Failed\u0026#34;); } /* This invokes an implicit conversion operator, which will be fatal at runtime if an error is returned */ let newVal = GetMinusOne(i); /* Result\u0026lt;T\u0026gt; contains a special \u0026#34;ReturnValueDiscarded\u0026#34; method which is invoked to facilitate failing fatally on ignored returned errors here */ GetMinusOne(i); /* \u0026#34;ReturnValueDiscarded\u0026#34; will not be called */ GetMinusOne(i).IgnoreError(); }  Result 也可通过 if 语句处理。使用 case 匹配 .Err 或 .Ok 枚举值。\nvoid Use() { /* Handle result via an if. Note that Result\u0026lt;T\u0026gt; returns are matched with \u0026#39;case\u0026#39;, not compared with \u0026#39;==\u0026#39; */ if (GetMinusOne(i) case .Ok(let newVal)) Console.WriteLine(\u0026#34;Val: {}\u0026#34;, newVal); }  断言 断言通过 Debug.Assert() 与 Runtime.Assert() 实现。Debug.Assert(cond) 在调试模式下若 cond 为 false 会触发致命错误，但在发布模式下不会生成任何指令（即使 cond 含有方法调用或复杂表达式）。断言通常用于“快速失败”以确保程序状态合法，而不用于处理可合法发生的错误（例如用户输入错误、超时等）。\n致命错误 当检测到不可恢复的错误时，可使用 Runtime.FatalError 手动“崩溃”程序。\n崩溃处理 默认情况下，GUI 程序会显示包含回溯的崩溃对话框，控制台程序则输出崩溃报告到控制台。可通过 Runtime.SetCrashReportKind 更改崩溃处理方式。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/preprocessor/",
	"title": "预处理器",
	"tags": [],
	"description": "",
	"content": " 预处理器 Beef 预处理器用于在解析器运行前按条件包含文本块并修改警告选项。它比 C 预处理器灵活性低，不能用于实现宏或其他“代码生成”用途。\n #define  - 将符号 \u0026ldquo;X\u0026rdquo; 设为 true #endif - 结束 #if、#else 或 #elif 块 #else - 若前一 #if/#elif 为 false，则处理直到下一个 #endif #elif  - 若前一 #if/#elif 为 false 且 \u0026ldquo;X\u0026rdquo; 为 true，则处理直到下一个 #endif #error  - 在解析时创建错误 #if  - 若 \u0026ldquo;X\u0026rdquo; 为 true，则处理直到下一个 #endif #pragma format disable - 禁用格式化 #pragma format restore - 恢复格式化 #pragma warning disable  - 禁用编号为 X 的警告 #pragma warning restore  - 恢复编号为 X 的警告 #undef  - 将符号 \u0026ldquo;X\u0026rdquo; 设为 false #unwarn - 禁用下一行源代码的警告 #warn  - 在解析时创建警告  内置预处理器符号  BF_32_BIT - 目标为 32 位 BF_64_BIT - 目标为 64 位 BF_ALLOW_HOT_SWAPPING - 启用热代码替换 BF_DEBUG_ALLOC - 使用调试分配器 BF_DYNAMIC_CAST_CHECK - 启用动态转换检查 BF_ENABLE_OBJECT_DEBUG_FLAGS - 对象头包含调试标志 BF_ENABLE_REALTIME_LEAK_CHECK - 启用实时泄漏检查 BF_HAS_VDATA_EXTENDER - 类带有 vdata 扩展器（用于热替换期间扩展 vtable） BF_LARGE_COLLECTIONS - 启用大集合（\u0026gt;1GB） BF_LARGE_STRINGS - 启用大字符串（\u0026gt;1GB） BF_LITTLE_ENDIAN - 目标为小端 BF_PLATFORM_IOS - iOS 目标 BF_PLATFORM_LINUX - Linux 目标 BF_PLATFORM_MACOS - macOS 目标 BF_PLATFORM_WINDOWS - Windows 目标 BF_RUNTIME_CHECKS - 启用运行时检查（如越界检查） BF_TEST_BUILD - 当前构建为 \u0026lsquo;test\u0026rsquo; 构建 DEBUG - 当前构建为 \u0026lsquo;debug\u0026rsquo; 构建  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/strings/",
	"title": "字符串",
	"tags": [],
	"description": "",
	"content": " 字符串概览 Beef 的 String 类型是可变对象，带有可调整的“小字符串优化”缓冲区，以 UTF8 存储字符数据。StringView 是一个 Span\u0026lt;char8\u0026gt; 的指针+长度结构体。按惯例，方法通过 StringView 参数接收字符串输入，需返回字符串数据的方法则使用 String 参数并向其追加数据。\n在同一工作区内值相同的字符串字面量会被合并，并拥有相同的对象地址；通过 char8* 转换或 CStr() 方法得到的以 null 结尾的 C 字符串指针也保证地址相同。生成的字符串若与某个字面量值相同，经过 String.Intern() 会返回该字面量的地址。\nString str = \u0026#34;This is a string\u0026#34;; char8* cStr = \u0026#34;This is a C string\u0026#34;; String str2 = \u0026#34;This string contains\\n Two lines\u0026#34;; String str3 = @\u0026#34;C:\\Path\\Literal\\NoSlashing\u0026#34;; String str4 = \u0026#34;\u0026#34;\u0026#34; \tMultiline string literal with a tabbed second line; \u0026#34;\u0026#34;\u0026#34;;  更多字符串字面量信息参见 字面量。\n字符串插值 字符串插值可用于字符串分配或字符串参数展开。\n/* This is equivalent to scope String()..AppendF(\u0026#34;X = {} Y = {}\u0026#34;, GetX(), GetY()) */ String str = scope $\u0026#34;X = {GetX()} Y = {GetY()}\u0026#34;; /* This is equivalent to Console.WriteLine(\u0026#34;X = {} Y = {}\u0026#34;, GetX(), GetY()) */ Console.WriteLine($\u0026#34;X = {GetX()} Y = {GetY()}\u0026#34;);  字符串对比    名称 可设定的非动态缓冲区 自定义动态分配器 编码     C 字符数组 是（用户指定数组大小） 不适用（无分配） char/wchar*   C++ std::string 否（固定小缓冲优化） 模板参数 char/wchar*   C# StringBuffer 否 否 UTF16   Beef 是 虚方法重写 UTF8    除 C 字符数组外，Beef 是唯一允许完全在栈上创建非小字符串（\u0026gt; 32 字节）的字符串实现：例如 var str = scope String(1024) 在栈上构建了一个内部缓冲为 1024 字符的 String。若需要超过内部缓冲的大小，可通过继承 String 并重写 Alloc/Free 与自定义分配器集成。在 C++ 中，字符串自定义分配器通过 std::basic_string 的模板参数提供，这意味着自定义分配器的字符串无法传给期望 std::string 的方法，因为类型不再匹配。就字符编码而言，C/C++ 不定义字符串字符的编码，因此编码问题完全交给用户处理。C# 的字符串出于历史原因使用 UTF16，这在很多方面是编码与大小的“双输”：用户仍需处理 UTF16 代理对（一个 Unicode 字符拆成两个 UTF16 字符），而 UTF16 字符串几乎总是比 UTF8 更大（即便仅处理亚洲语言）。\n易用性 在处理字符串时，参数级联运算符 尤其有用。为了让用户掌控分配，字符串通常以参数形式传入方法并在其中被修改。这类方法多返回 void，因此不会损失返回值，但返回 Result 的方法无法很好地使用这种方式。\nvoid ToString(String strBuffer) { strBuffer.Append(\u0026#34;Count: \u0026#34;); count.ToString(strBuffer); } { let printString = scope String(); ToString(printString); Console.WriteLine(printString); /* 与上面等价。ToString 被设计为返回传入的 String */ let printString2 = ToString(.. scope String()); Console.WriteLine(printString2); /* 等价的一行写法。\u0026#39;.\u0026#39; 可用于推断 \u0026#39;String\u0026#39;，因为传入 ToString 的类型明确 */ Console.WriteLine(ToString(.. scope .())); } { let filePath = Path.InternalCombine(.. scope .(), rootDir, \u0026#34;Folder\u0026#34;, \u0026#34;file.bin\u0026#34;); }  常见字符串错误 /* 错误 - 字符串字面量位于只读内存，不能修改 */ String newString = \u0026#34;Hello, \u0026#34;; newString.Append(name); /* 正确 */ String newString = scope String()..AppendF(\u0026#34;Hello, {}\u0026#34;, name); /* 正确 - 与上面的代码等价 */ String newString = scope $\u0026#34;Hello, {name}\u0026#34;; /* 错误 - 剥夺了用户对分配的控制，并将释放内存的负担交给调用方 */ String GetName() { return new String(\u0026#34;Brian\u0026#34;); } /* 更错误 - 返回时该内存已离开作用域，不能将栈分配内存返回给调用方 */ String GetName() { return scope String(\u0026#34;Brian\u0026#34;); } /* 正确 - 注意使用 Append，可避免创建需要后续拼接的临时字符串 */ void GetName(String outName) { outName.Append(\u0026#34;Brian\u0026#34;); } /* 错误 - 字符串值不能直接相加 */ String strC = strA + strB; /* 正确 - 已提供分配 */ String strC = scope $\u0026#34;{strA}{strB}\u0026#34;; /* 正确 - 字符串常量可相加，因为结果仍是字符串常量，运行时无需分配 */ String strC = \u0026#34;A\u0026#34; + \u0026#34;B\u0026#34;; /* 正确 - 等价于 strC.Append(strA) */ strC += strA; "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/typerefs/",
	"title": "类型引用",
	"tags": [],
	"description": "",
	"content": " 特殊类型引用  Self - 定义该成员的类型；在接口中使用时，表示实现该接口的类型 SelfBase - 定义该成员类型的基类 SelfOuter - 定义该成员类型的外部类型 var/let - 创建变量时用于类型推断，var 创建可变变量，let 创建常量或只读变量 . - . 类型用于类型推断，表示“期望类型”。最常见的用途是在不指定类型名的情况下，将隐式转换改为显式转换。（例如：intVal = (.)floatVal）  "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/comptime/",
	"title": "编译期（Comptime）",
	"tags": [],
	"description": "",
	"content": " 编译期（Comptime） Beef 提供编译期特性，可用于执行能求值为常量的代码或生成代码。\n编译期方法求值 /* 使用 Vector3 构造函数的编译期求值来初始化常量 */ const Vector3 vec = .(1, 2, 3); /* 普通方法也可在编译期使用 */ static int32 Factorial(int32 n) { return n \u0026lt;= 1 ? 1 : (n * Factorial(n - 1)); } const int fac = Factorial(8); var fac2 =[ConstEval]Factorial(9); /* 调用特性强制编译期求值 */ /* 该方法只能在编译期调用。\u0026#39;var\u0026#39; 返回类型允许它根据输入在编译期返回不同类型 */[Comptime(ConstEval=true)] static var StrToValue(String str) { if (str.Contains(\u0026#39;.\u0026#39;)) return float.Parse(str).Value; return int.Parse(str).Value; } public const let cVal0 = StrToValue(\u0026#34;123\u0026#34;); /* 求值为 \u0026#39;int\u0026#39; */ public const let cVal1 = StrToValue(\u0026#34;1.23\u0026#34;); /* 求值为 \u0026#39;float\u0026#39; */ /* 注意：返回作用域内存在编译期是合法的，但在运行期是不合法的 */ static String GenerateString(String str, int a, int b) =\u0026gt; scope $\u0026#34;{str}:{a}:{b}\u0026#34;; const String cStr = GenerateString(\u0026#34;Prefix\u0026#34;, 12, 34); /* 求值为字符串字面量 \u0026#34;Prefix:12:34\u0026#34; */ /* Span 结果可用于初始化定长数组 */ public static Span\u0026lt;int32\u0026gt; GetSorted(String numList) { List\u0026lt;int32\u0026gt; list = scope .(); for (var sv in numList.Split(\u0026#39;,\u0026#39;)) { sv.Trim(); if (int32.Parse(sv) case .Ok(let val)) list.Add(val); } list.Sort(); return list; } const int32[?] iArr = GetSorted(\u0026#34;8, 1, 3, 7\u0026#34;); /* 求值为 int32[4](1, 3, 7, 8) */  每次编译期求值都是隔离执行的——在一次方法求值过程中修改的静态值不会对后续方法求值可见。编译期求值限制某些副作用，例如文件 IO 与访问外部库。\n编译期代码生成 代码生成在编译期方法求值特性的基础上扩展，允许在编译过程中某些触发点修改类型。\n/* 常量字符串可在编译期注入到调用点。该字符串可由编译期方法生成。 */ { /* 在此例中等同于直接把字符串粘贴到代码中。 */ Compiler.Mixin(\u0026#34;int val = 99;\u0026#34;); Console.WriteLine(val); } /* OnCompile 特性允许代码生成 */ class ClassA { public int mA = 123;[OnCompile(.TypeInit), Comptime] public static void Generate() { Compiler.EmitTypeBody(typeof(Self), \u0026#34;\u0026#34;\u0026#34; \tpublic int32 mB = 234; public int32 GetValB() =\u0026gt; mB; \u0026#34;\u0026#34;\u0026#34;); \t} } /* 该方法会在调用点注入运行时作用域计时器。 */[Comptime] public static void TimeScope(String scopeName) { let nameHash = (uint)scopeName.GetHashCode(); /* MixinRoot 会注入到最外层的非编译期调用者，而不是注入到该编译期方法中 */ Compiler.MixinRoot(scope $\u0026#34;\u0026#34;\u0026#34; let __timer_{nameHash} = scope System.Diagnostics.Stopwatch(true); defer {{ System.Console.WriteLine($\u0026#34;Scope {scopeName} took {{__timer_{nameHash}.ElapsedMilliseconds}}ms.\u0026#34;); \t}} \u0026#34;\u0026#34;\u0026#34;); } /* 给类型添加该特性会通过编译期反射生成 \u0026#39;ToString\u0026#39; 方法 */[AttributeUsage(.Types)] struct IFancyToStringAttribute : Attribute, IOnTypeInit {[Comptime] public void OnTypeInit(Type type, Self* prev) { Compiler.EmitTypeBody(type, \u0026#34;public override void ToString(String str)\\n{\\n\u0026#34;); int strElementIdx = 0; for (var fieldInfo in type.GetFields()) { if ((!fieldInfo.IsInstanceField) || ((fieldInfo.IsPrivate) \u0026amp;\u0026amp; (fieldInfo.DeclaringType != type))) continue; if (strElementIdx \u0026gt; 0) Compiler.EmitTypeBody(type, \u0026#34;\\tstr.Append(\\\u0026#34;, \\\u0026#34;);\\n\u0026#34;); Compiler.EmitTypeBody(type, scope $\u0026#34;\\tstr.AppendF($\\\u0026#34;{fieldInfo.Name}={{ {fieldInfo.Name} }}\\\u0026#34;);\\n\u0026#34;); strElementIdx++; } Compiler.EmitTypeBody(type, \u0026#34;}\u0026#34;); } } /* 给方法添加该特性会记录方法入口，并记录返回的 Result\u0026lt;T\u0026gt; 错误 */[AttributeUsage(.Method)] struct LogAttribute : Attribute, IOnMethodInit {[Comptime] public void OnMethodInit(MethodInfo method, Self* prev) { String emit = scope $\u0026#34;Logger.Log($\\\u0026#34;Called {method}\u0026#34;; \tfor (var fieldIdx \u0026lt; method.ParamCount) emit.AppendF($\u0026#34; {{ {method.GetParamName(fieldIdx)} }}\u0026#34;); emit.Append(\u0026#34;\\\\n\\\u0026#34;);\u0026#34;); Compiler.EmitMethodEntry(method, emit); if (var genericType = method.ReturnType as SpecializedGenericType) { if ((genericType.UnspecializedType == typeof(Result\u0026lt;\u0026gt;)) || (genericType.UnspecializedType == typeof(Result\u0026lt;,\u0026gt;))) { Compiler.EmitMethodExit(method, \u0026#34;\u0026#34;\u0026#34; \tif (@return case .Err) Logger.Log($\u0026#34;Error: {@return}\u0026#34;); \u0026#34;\u0026#34;\u0026#34;); \t} } } } interface ISerializable { public void Serialize(Serializer s); } /* 给类型添加该特性会添加并实现 ISerializable 接口 */ struct SerializableAttribute : Attribute, IOnTypeInit {[Comptime] public void OnTypeInit(Type type, Self* prev) { Compiler.EmitAddInterface(type, typeof(ISerializable)); Compiler.EmitTypeBody(type, \u0026#34;\u0026#34;\u0026#34; \tpublic void ISerializable.Serialize(Serializer serializer) { \u0026#34;\u0026#34;\u0026#34;);  Compiler.EmitTypeBody(type, scope $\u0026#34;\\tserializer.StartType(typeof({type.GetName(.. scope .())}));\\n\u0026#34;); for (let field in type.GetFields()) { if (!field.IsInstanceField || field.DeclaringType != type) continue; Compiler.EmitTypeBody(type, scope $\u0026#34;\\tserializer.Store(\\\u0026#34;{field.Name}\\\u0026#34;, {field.Name});\\n\u0026#34;); } Compiler.EmitTypeBody(type, \u0026#34;\\tserializer.EndType();\\n}\u0026#34;); } }[AttributeUsage(.Field | .StaticField)] struct RangedAccessorAttribute : this(int minVal, int maxVal), Attribute, IOnFieldInit {[Comptime] public void OnFieldInit(FieldInfo fieldInfo, Self* prev) mut { Compiler.EmitTypeBody(fieldInfo.DeclaringType, scope $\u0026#34;\u0026#34;\u0026#34; public {(fieldInfo.IsStatic ? \u0026#34;static\u0026#34; : \u0026#34;\u0026#34;)} {fieldInfo.FieldType} Ranged{fieldInfo.Name} \t{{ get =\u0026gt; {fieldInfo.Name}; set {{ System.Runtime.Assert((value \u0026gt;= {minVal}) \u0026amp;\u0026amp; (value \u0026lt;= {maxVal})); {fieldInfo.Name} = value; }} }} \u0026#34;\u0026#34;\u0026#34;); \t} } /* 创建一个包装 \u0026#39;Val\u0026#39; 的 \u0026#39;RangedVal\u0026#39; 属性，仅允许 10 到 20 的值 */[RangedAccessor(10, 20)] static int Val; "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/testing/",
	"title": "测试",
	"tags": [],
	"description": "",
	"content": "每个工作区默认都包含一个 “Test” 配置，可以通过向 BeefBuild 传入 “-test” 或在 IDE 的 “Test” 菜单中执行。测试通过在任意静态方法上添加 [Test] 特性来定义。\n[Test] public static void TestAPI() { Test.Assert(API_Init()); Test.Assert(API_GetVersion() == 12); }  在某些情况下，测试应当失败。可使用 [Test] 特性进行标记。\n[Test(ShouldFail=true)] public static void TestBoundsCheck() { let array = scope int8[5]; /* The following will fail a Runtime.Assert in the array indexer, thus failing the test */ let num = array[5]; }  在工作区属性中，确保 “Projects” 中需要运行测试的项目都指定了 “Test” 配置。默认情况下，工作区中列出的第一个项目会被用于测试。\nBeef 测试适用于 Jenkins 等 CI 系统：BeefBuild 会输出包含耗时统计的测试文本，并通过标准返回码报告成功或失败。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/faq/",
	"title": "常见问题",
	"tags": [],
	"description": "",
	"content": " 是否有 Visual Studio Code 语言服务器扩展？ 对此有过兴趣，但目前未计划作为官方项目。如果 BeefLang 社区有人愿意开展此事，最好从 BeefBuild/IDE 项目基础开始，因为大量项目管理功能都在该代码库中。尽管 IDEHelper 项目包含编译器，看起来是语言服务器的起点，但仍缺少关键功能。\n为什么 IDE 只支持 Windows？ Beef 的首要目标是游戏开发。大多数游戏开发在 Windows 上完成，因此必须优先把主要开发体验做到最好。\n要让 IDE 在 Linux 或 macOS 上运行，需要做哪些工作？ 常见的看法是依赖 DirectX 做 GUI 渲染是主要问题，但这只是工作的一小部分。实际上，BeefySysLib/platform/sdl 已经存在部分 OpenGL 渲染后端。还有许多其他 GUI 相关问题需要解决，例如处理平台特定的打开/保存/选择文件夹对话框、系统菜单、多显示器支持、不同的快捷键标准，以及许多尚未发现的系统问题。调试器是更大的问题——Windows IDE 使用自定义的 Windows 专用调试引擎，这是热代码替换支持的核心部分。较好的方式可能是封装 LLDB 引擎，并扩展其以支持热代码替换。\n为什么没有 Linux 或 macOS 的二进制包？ 以后会有的。\nBeef 是否支持主机平台？ 相关工作尚未开始，但这是优先事项之一。\nBeefLang 开发了多久？ 语言与 IDE 的工作于 2014 年 9 月开始，首次公开发布是在 2020 年 1 月。\nBeef 现在适合用于生产环境吗？ Beef 是一门新语言，有其优点和缺点——早期使用者可以帮助塑造语言方向，并常能得到针对问题的直接关注。但新语言难免会有不兼容变更，也可能比成熟语言包含更多 bug。Beef 的 bug 通常修复得很快。\n我可以如何贡献？ 最好的方式是直接使用 Beef，即便是小项目也可以，遇到 bug 或建议可提交 GitHub issue，并向他人分享你的体验。参与核心库建设也是很好的方向，因为在很多明显领域仍有欠缺。\n我可以通过 Patreon 等方式资助 Beef 吗？ 该项目目前不需要资金支持。\n你是谁？ BeefLang 由 PopCap Games 联合创始人 Brian Fiete 发起，他在 2011 年之前一直在 PopCap 任职。自 2014 年 9 月以来，Brian 基本上一直全职投入 BeefLang。\n我不喜欢语言的名字或标志，会改吗？ Logo 可能会变，但名称不会更改。\n有计划支持 async/await 或协程吗？ 这些会在 BeefLang 的未来版本中考虑。\n如何获取当前可执行文件的名称？ System.Environment.GetExecutableFilePath\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/",
	"title": "Beef 语言",
	"tags": [],
	"description": "",
	"content": " 语言指南概览 Beef 语言指南仍在完善中，用于介绍 Beef 编程语言。\n如果你喜欢通过示例学习，Beef 自带多个示例项目，用于展示语言概念的基础。Beef IDE 与相关工具的源代码托管在 GitHub，可作为完整规模项目的参考。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/ide/themes/",
	"title": "主题",
	"tags": [],
	"description": "",
	"content": " 主题 IDE 支持主题文件，可用于自定义外观。主题文件应放置在 bin/themes 目录下的子目录中。用户可在 File\\Preferences\\Settings 的 UI\\Theme 中设置主题。该值可以是相对于 themes 目录的目录名，或相对于 theme 目录的主题 .toml 文件。\n替换图像需要提供包含图像分片的 PSD 文件，以覆盖标准的 bin/images/DarkUI.png、bin/images/DarkUI_2.png 和 bin/images/DarkUI_4.png。主题文件应分别命名为 UI.psd、UI_2.psd 和 UI_4.psd，它们对应不同的缩放等级。\n并非所有图像文件都必须存在，也不必在每个文件中填充所有图像分片。缺失的部分会用其他主题图像文件的缩放分片或默认分片补齐。例如，仅提供一个 UI_4.psd 文件并只替换复选框分片也是可以的。但对于需要清晰边缘的分片，一般建议提供 1x 缩放的 UI.png 图像，因为缩放可能导致边缘对不齐或模糊。\n当用户在 IDE 中选择你的主题时，会执行 bin/images/ImgCreate.exe，通过缩放并合并 PSD 生成 UI.png、UI_2.png 和 UI_4.png。这些文件应视为缓存文件，当源文件变化时会自动重建，从而既能更新主题，也能兼容未来 IDE 版本新增的图像分片。\n主题还支持通过 theme.toml 覆盖颜色设置。\n[Colors] Text = 0xFFFFFFFF Window = 0xFF595962 Background = 0xFF26262A SelectedOutline = 0xFFCFAE11 MenuFocused = 0xFFE5A910 MenuSelected = 0xFFCB9B80 Code = 0xFFFFFFFF Keyword = 0xFFE1AE9A Literal = 0xFFC8A0FF Identifier = 0xFFFFFFFF Comment = 0xFF75715E Method = 0xFFA6E22A Type = 0xFF66D9EF RefType = 0xFF66D9EF Interface = 0xFF66D9EF Namespace = 0xFF7BEEB7 DisassemblyText = 0xFFB0B0B0 DisassemblyFileName = 0XFFFF0000 Error = 0xFFFF0000 BuildError = 0xFFFF8080 BuildWarning = 0xFFFFFF80 VisibleWhiteSpace = 0xFF9090C0  用户可在主题目录中提供 user.toml 文件，该文件会在 theme.toml 之后处理，用于覆盖一个或多个主题设置。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/ide/codegeneration/",
	"title": "代码生成",
	"tags": [],
	"description": "",
	"content": " 生成器概览 Beef IDE 允许通过源代码中的生成器来生成源文件。最简单的例子是 NewClassGenerator。在工作区面板中右键并选择 “Generate File\u0026hellip;” 即可访问。继承自 Compiler.Generator 的类会自动显示在 “Generate File” 面板的 “Generator” 下拉框中。生成器方法由编译器直接执行，无需手动编译。\n生成器既可用于创建自定义文件模板，也可生成包含完整源码的整份文件。\npublic class NewClassGenerator : Compiler.Generator { public override String Name =\u0026gt; \u0026#34;New Class\u0026#34;; // This is was the generator will show up as in the \u0026#34;Generator\u0026#34; dropdown  public override void InitUI() { AddEdit(\u0026#34;name\u0026#34;, \u0026#34;Class Name\u0026#34;, \u0026#34;\u0026#34;); } public override void Generate(String outFileName, String outText, ref Flags generateFlags) { var name = mParams[\u0026#34;name\u0026#34;]; if (name.EndsWith(\u0026#34;.bf\u0026#34;, .OrdinalIgnoreCase)) name.RemoveFromEnd(3); outFileName.Append(name); outText.AppendF( $\u0026#34;\u0026#34;\u0026#34; namespace {Namespace} {{ class {name} {{ }} }} \u0026#34;\u0026#34;\u0026#34;); } }  可在上述任一方法中调用 Fail(...) 以返回错误。\n生成器 UI 当在 “Generator” 下拉框中选择生成器时，会调用 InitUI()，用于创建生成器输入所需的 UI。传给这些方法的第一个参数是参数名，稍后可由 Generate 方法用于读取传入值。\nAddEdit(...); // Adds an input field AddCombo(...); // Adds a dropdown selection AddCheckbox(...); // Adds a checkbox  // For example, a dropdown selection with the options A, B and C, where B is the default selection. AddCombo(\u0026#34;type\u0026#34;, \u0026#34;Type\u0026#34;, \u0026#34;B\u0026#34;, StringView[?](\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;)); // ... in Generate, we can retrieve this input from mParams let type = mParams[\u0026#34;type\u0026#34;];  源码生成 在 Generate() 中，通过向方法传入的 outFileName 与 outFile 字符串追加内容来输出结果。outFileName 不应包含 \u0026ldquo;.bf\u0026rdquo; 扩展名。\n所有输入都是 StringView，通过 mParams[...]（使用在 InitUI 中定义的参数名）获取。注意：对于复选框，返回字符串为 bool.TrueString 或 bool.FalseString。也可使用 GetString(...) 将 StringView 追加到传入字符串。\n// For example... let type = mParams[\u0026#34;type\u0026#34;]; bool option = (mParams[\u0026#34;option\u0026#34;] == bool.TrueString);  可通过 getter 访问若干内置参数。例如，上面的示例使用 Namespace 根据项目和文件位置获取命名空间。可用参数如下： - ProjectName - 当前项目名称 - ProjectDir - 当前项目路径 - FolderDir - 文件生成到的目录路径 - Namespace - 文件命名空间（包含文件相对路径作为子命名空间） - DefaultNamespace - 当前项目的默认命名空间 - WorkspaceName - 当前工作区名称 - WorkspaceDir - 当前工作区路径 - DateTime - 生成时的当前时间 - IsRegenerating - 指示生成器是否用于重新生成文件\n重新生成 生成器可在 Generate 调用期间，通过在 generateFlags 上设置 .AllowRegenerate 来允许文件重新生成。当生成完整可用的源代码时，更新生成器后即可轻松重新生成之前的文件。注意：重新生成会从头重写文件内容，所有手动改动都会被丢弃。\n标记为可重新生成的生成器，会将配置保存在重新生成文件顶部的注释中。该注释的存在是文件可被识别为可重新生成的必要条件。注释内容可编辑，例如添加或修改新的生成器输入。GetString(...) 可用于判断是否提供了某个输入（旧文件并不了解新增的生成器参数），从而在缺失时使用默认值。mParams[...] 是字典，传入未知键时会直接报错。\n可右键文件并选择 “Regenrate” 选项进行重新生成。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/datatypes/globals/",
	"title": "全局",
	"tags": [],
	"description": "",
	"content": " 全局 全局变量可视为匿名类型的静态字段。也可以定义全局方法与 mixin。\nstatic { public static int gGlobalVal = 0; }  通过 using static 可以在文件级别实现类似全局变量的简洁性，使得可以在当前类型外直接使用静态字段。\nclass Image { public static int sImageCount; } using static Image; class Program { public void Use() { // 这种静态使用通常需要完全限定名 \u0026#34;Image.sImageCount\u0026#34;; \tint imgCount = sImageCount; } } "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/ide/commandline/",
	"title": "命令行参数",
	"tags": [],
	"description": "",
	"content": " Beef IDE 命令行参数 Beef IDE 是一款 GUI 应用，本身不需要参数，但支持一些可选参数。\n   参数 说明     -config=\u0026lt;config\u0026gt; 设置配置   -launch 在调试器中编译并运行工作区启动项目。\u0026rsquo;\u0026ndash;\u0026rsquo; 之后的内容会作为参数传入   -launch=\u0026lt;path\u0026gt; 在调试器中编译并运行可执行文件 \u0026lsquo;path\u0026rsquo;。\u0026rsquo;\u0026ndash;\u0026rsquo; 之后的内容会作为参数传入   -launchDir=\u0026lt;path\u0026gt; 设置启动工作目录   -launchPaused 与 \u0026lsquo;-launch\u0026rsquo; 一起使用，启动调试器时暂停   -new 创建新的工作区和项目   -path\u0026lt;Path\u0026gt; 设置目标文件（具体操作取决于文件类型）   -platform=\u0026lt;platform\u0026gt; 设置平台   -test=\u0026lt;path\u0026gt; 执行测试脚本   -verbosity=\u0026lt;verbosity\u0026gt; 设置详细程度：quiet/minimal/normal/detailed/diagnostics   -workspace=\u0026lt;path\u0026gt; 设置工作区路径    "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/ide/profiling/",
	"title": "性能分析",
	"tags": [],
	"description": "",
	"content": " 性能分析概览 Beef IDE 的性能分析器是采样式分析器，会在每秒多次采集目标应用的调用栈样本，并在分析会话结束后生成整体性能报告。延长采样时间或提高采样率可提升报告准确性。\n在目标程序执行期间可随时启动性能分析，甚至可由目标程序通过 \u0026ldquo;System.Diagnostics.Profiler\u0026rdquo; 类主动请求。这在需要对程序定义的时间段进行分析时很有用，例如执行某个长计算时。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/ide/documentation/",
	"title": "文档",
	"tags": [],
	"description": "",
	"content": " 文档注释 IDE 支持使用 /// 或 /** */ 为类型和方法编写文档（使用哪种都可以）。自动补全建议以及调用/使用这些类型或函数时的提示，会显示对应文档。\nstatic { /// Must be placed directly above the method, including attributes. \t/// Using multiple lines like this is also fine. Both will be recognized. [Optimize] public static void DoAThing() {} /// Documentation also works for types. \tstruct SomeStruct { /** * Multiline comment with two ** at the start works in the same way. */ void PrivateMethod() {} } /** * If you have a really long explainer here, you may not actually want to show that in autcompletion prompts. * @brief Allows you to select only this line to be shown. * * @param a This is shown when writing a call to this function and placing parameter \u0026#34;a\u0026#34;. * @param b For the second argument, the documentation for b (this!) will show up instead. */ public static void DoAnotherThing(int a, int b) {} } "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/language-guide/datatypes/methodrefs/",
	"title": "方法引用",
	"tags": [],
	"description": "",
	"content": " 函数指针 函数指针类型可指向静态方法、带显式 this 参数的非静态方法、外部函数，或由库动态生成的函数。函数指针通过 =\u0026gt; 运算符生成。\n/* 局部变量 `funcPtr` */ function void() funcPtr = =\u0026gt; StaticMethod; funcPtr(); /* 作为参数传递给另一个方法 */ void UseFuncPtr(function void() funcPtrB) =\u0026gt; funcPtrB(); UseFuncPtr(=\u0026gt; StaticMethodB); /* 注意此处未捕获 \u0026#39;ca\u0026#39;。也可以写成 \u0026#39;ClassA.MemberMethod\u0026#39; */ ClassA ca = new ClassA(); function void(ClassA this, float f) funcPtr2 = =\u0026gt; ca.MemberMethod; funcPtr2(ca, 1.2f); /* 注意结构体需要区分 mut/非 mut */ StructA sa = StructA(); function void(mut StructA this, float f) funcPtr3 = =\u0026gt; sa.MemberMethod; funcPtr3(mut sa, 2.3f); /* 注意：在互操作中，所有 [CRepr] 结构体都会以指针传递，无论是否指定 mut，调用约定相同 */  委托 委托更为通用，定义为类类型，不仅能引用函数指针可引用的对象，还能引用实例方法，并在指向局部方法或 lambda 时捕获局部变量。委托通过带分配标记的 =\u0026gt; 运算符分配。\ndelegate void() delegateVal = scope =\u0026gt; MemberMethod;  事件 事件可视为多播委托。System.Event\u0026lt;T\u0026gt; 结构体包装了委托类型，可包含零个或多个委托引用。\nEvent\u0026lt;delegate void(int)\u0026gt; evt = default; /* 注意使用 \u0026#39;new =\u0026gt;\u0026#39;，因为 Event 会接管委托的所有权 */ evt.Add(new =\u0026gt; obj.MethodA); evt.Add(new =\u0026gt; obj.MethodB); /* 将按添加顺序调用委托 */ evt(intVal); /* 移除单个委托。注意使用 \u0026#39;scope\u0026#39;，因为该参数仅用于比较，不会转移所有权 */ evt.Remove(scope =\u0026gt; obj.MethodA, true); /* Dispose 将删除所有剩余委托 */ evt.Dispose();  Lambda Lambda 是创建局部方法并分配委托指向它的简写形式，同时允许定义 lambda 析构函数，用于释放 lambda 生命周期内所需的资源。\nstatic void Test(StringView str) { int i = 0; /* 本地定义的方法，按引用捕获 \u0026#39;i\u0026#39; */ char8 GetNext() { if (i \u0026gt;= str.Length) return 0; return str[i++]; } /* 本地定义的方法，不捕获任何变量 */ char8 GetEmpty() { return 0; } /* 分配绑定到 GetNext() 的委托 */ delegate char8() strDlg = scope =\u0026gt; GetNext; /* 将 emptyFunc 绑定到 GetEmpty()。绑定到 GetNext() 会失败，因为函数指针无法持有捕获 */ function char8() emptyFunc = =\u0026gt; GetEmpty; /* 分配 lambda */ strDlg = scope () =\u0026gt; { return \u0026#39;A\u0026#39;; }; /* 分配按引用捕获的 lambda，使 GetNext 调用能够捕获 \u0026#39;i\u0026#39; */ strDlg = scope[\u0026amp;] () =\u0026gt; { return GetNext(); }; /* 该 lambda 持有一个字符串，在 lambda 作用域结束后清理 */ String tempStr = new String(str); tempStr.EnsureNullTerminator(); /* 按引用捕获 \u0026#39;i\u0026#39;，按值捕获 str 与 tempStr */ strDlg = scope[\u0026amp;i, =str, =tempStr] () =\u0026gt; { return tempStr[i]; } ~ { delete tempStr; }; }  无值方法引用 无值方法引用可用于特化某些泛型方法，使其直接调用目标方法而非通过委托间接调用。在某些关键路径上可提升性能。\nstatic T Max\u0026lt;T, TFunc\u0026gt;(T lhs, T rhs, TFunc func) where TFunc : delegate int(T lhs, T rhs) { return (func(lhs, rhs) \u0026gt;= 0) ? lhs : rhs; } int CmpVec(Vector2 lhs, Vector2 rhs) { return lhs.x \u0026lt;=\u0026gt; rhs.x; } /* 该调用的 \u0026#39;func\u0026#39; 参数为无值引用 - 会生成特化的 \u0026#39;Max\u0026#39; 方法直接调用 CmpVec */ Vector2 max = Max(vec0, vec1, =\u0026gt; CmpVec); "
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/ide/hotcompile/",
	"title": "热编译",
	"tags": [],
	"description": "",
	"content": " 热编译概览 当通过 IDE 执行 Beef 应用时，允许对源码进行“热”修改。编译请求成功完成后，新生成的目标文件（如有）会被热补丁到正在运行的可执行文件中。修改后的方法通过在旧方法开头（安全地）插入跳转到新方法来完成替换。这意味着对于长时间运行的方法，旧代码可与新代码并行存在，因为热补丁后调用的方法才会“切换”到新代码。IDE 会维护旧源码映射，用于在被替换方法中单步调试、将新的断点映射到旧方法等。\n许多其他编译器特性也对热代码修改提供特殊调试支持，包括添加/移除虚方法、向字符串驻留表添加新字面量、添加新的 DLL 导入方法、修改反射信息、保持函数指针地址一致性等。\n如果程序能够热补丁到仅使用新数据布局，结构体和类的数据布局变更也是允许的。因此，只要仍存在旧布局的活动分配，或在活动调用栈中使用旧布局，就会产生编译错误（但不会导致运行时数据损坏或崩溃）。\n"
},
{
	"uri": "https://2505817596.github.io/BeefDocs/docs/ide/watch/",
	"title": "调试器表达式",
	"tags": [],
	"description": "",
	"content": " 调试器监视表达式 调试器监视表达式求值器可评估大多数常规 Beef 表达式，包括访问属性与调用方法。 除这些表达式外，还支持一些特殊监视表达式。\n   表达式 说明     {\u0026lt;number\u0026gt;} \u0026lt;expr\u0026gt; or {^\u0026lt;number\u0026gt;} \u0026lt;expr\u0026gt; 在调用栈向上第 \u0026lt;number\u0026gt; 层处求值表达式   {MethodName} \u0026lt;expr\u0026gt; 在调用栈向上第一个名为 MethodName 的方法中求值表达式   {MethodName^\u0026lt;number\u0026gt;} \u0026lt;expr\u0026gt; 在调用栈向上第 \u0026lt;number\u0026gt; 个名为 MethodName 的方法中求值表达式   {*} \u0026lt;expr\u0026gt; 在调用栈中第一个表达式有效的作用域里求值    格式标志 以下标志可加在监视表达式之后，用逗号分隔。\n   标志 说明     this=\u0026lt;expr\u0026gt; 为表达式显式设置 \u0026lsquo;this\u0026rsquo; 值   arraysize=\u0026lt;number\u0026gt; 将表达式显示为包含 \u0026lt;number\u0026gt; 个元素的数组   \u0026lt;number\u0026gt; 将表达式显示为包含 \u0026lt;number\u0026gt; 个元素的数组   d 十进制   s ASCII   s8 UTF8   s16 UTF16   s32 UTF32   na 隐藏指针   nv 不使用可视化器   x 十六进制（小写）   X 十六进制（大写）    "
}]