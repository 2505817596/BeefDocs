<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Beef Corlib: System.Collections.HashSet&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Beef Corlib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_system.html">System</a></li><li class="navelem"><a class="el" href="namespace_system_1_1_collections.html">Collections</a></li><li class="navelem"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html">HashSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_system_1_1_collections_1_1_hash_set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">System.Collections.HashSet&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;, using a buckets array to map hash values to the Slots array.  
 <a href="class_system_1_1_collections_1_1_hash_set.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for System.Collections.HashSet&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_system_1_1_collections_1_1_hash_set.png" usemap="#System.Collections.HashSet_3C_20T_20_3E_map" alt=""/>
  <map id="System.Collections.HashSet_3C_20T_20_3E_map" name="System.Collections.HashSet_3C_20T_20_3E_map">
<area href="interface_system_1_1_collections_1_1_i_enumerable.html" alt="System.Collections.IEnumerable&lt; T &gt;" shape="rect" coords="0,0,227,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_collections_1_1_hash_set_1_1_enumerator.html">Enumerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad52b19a168ed161ad3e30899e95ce551"><td class="memItemLeft" align="right" valign="top"><a id="ad52b19a168ed161ad3e30899e95ce551"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HashSet</b> (int wantSize)</td></tr>
<tr class="separator:ad52b19a168ed161ad3e30899e95ce551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13717f7d3756f07db2c595dd62c08e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a13717f7d3756f07db2c595dd62c08e51">Clear</a> ()</td></tr>
<tr class="memdesc:a13717f7d3756f07db2c595dd62c08e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add item to this hashset.  <a href="class_system_1_1_collections_1_1_hash_set.html#a13717f7d3756f07db2c595dd62c08e51">More...</a><br /></td></tr>
<tr class="separator:a13717f7d3756f07db2c595dd62c08e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507f17b20d92c5e771eff290c0f5c72b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a507f17b20d92c5e771eff290c0f5c72b">Contains</a> (T item)</td></tr>
<tr class="memdesc:a507f17b20d92c5e771eff290c0f5c72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this hashset contains the item.  <a href="class_system_1_1_collections_1_1_hash_set.html#a507f17b20d92c5e771eff290c0f5c72b">More...</a><br /></td></tr>
<tr class="separator:a507f17b20d92c5e771eff290c0f5c72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56775955597aa70d937f9ce7b0857d1"><td class="memItemLeft" align="right" valign="top"><a id="af56775955597aa70d937f9ce7b0857d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ContainsWith&lt; TAltKey &gt;</b> (TAltKey item)</td></tr>
<tr class="separator:af56775955597aa70d937f9ce7b0857d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd441237d4eb8f7ba86345315bbb474"><td class="memItemLeft" align="right" valign="top"><a id="a9dd441237d4eb8f7ba86345315bbb474"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ContainsAlt&lt; TAltKey &gt;</b> (TAltKey item)</td></tr>
<tr class="separator:a9dd441237d4eb8f7ba86345315bbb474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407d3d4b0ca0ae486c39c06c237b3d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a407d3d4b0ca0ae486c39c06c237b3d16">CopyTo</a> (T[] array, int32 arrayIndex)</td></tr>
<tr class="memdesc:a407d3d4b0ca0ae486c39c06c237b3d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy items in this hashset to array, starting at arrayIndex.  <a href="class_system_1_1_collections_1_1_hash_set.html#a407d3d4b0ca0ae486c39c06c237b3d16">More...</a><br /></td></tr>
<tr class="separator:a407d3d4b0ca0ae486c39c06c237b3d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0992cfc11d299a4176d1fa6d44e3cd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#aa0992cfc11d299a4176d1fa6d44e3cd5">Remove</a> (T item)</td></tr>
<tr class="memdesc:aa0992cfc11d299a4176d1fa6d44e3cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove item from this container.  <a href="class_system_1_1_collections_1_1_hash_set.html#aa0992cfc11d299a4176d1fa6d44e3cd5">More...</a><br /></td></tr>
<tr class="separator:aa0992cfc11d299a4176d1fa6d44e3cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7860cbdba0a47d2c9cffb1a254cfcf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_system_1_1_result.html">Result</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#ab7860cbdba0a47d2c9cffb1a254cfcf3">GetAndRemove</a> (T item)</td></tr>
<tr class="memdesc:ab7860cbdba0a47d2c9cffb1a254cfcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove item from this container.  <a href="class_system_1_1_collections_1_1_hash_set.html#ab7860cbdba0a47d2c9cffb1a254cfcf3">More...</a><br /></td></tr>
<tr class="separator:ab7860cbdba0a47d2c9cffb1a254cfcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976e1ccadf2eb15605fe3ac939690759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_system_1_1_result.html">Result</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a976e1ccadf2eb15605fe3ac939690759">GetAndRemoveAlt&lt; TAltKey &gt;</a> (TAltKey item)</td></tr>
<tr class="memdesc:a976e1ccadf2eb15605fe3ac939690759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove item from this container.  <a href="class_system_1_1_collections_1_1_hash_set.html#a976e1ccadf2eb15605fe3ac939690759">More...</a><br /></td></tr>
<tr class="separator:a976e1ccadf2eb15605fe3ac939690759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e1daad52bb15aefb5eff0f5d55f543"><td class="memItemLeft" align="right" valign="top"><a id="af7e1daad52bb15aefb5eff0f5d55f543"></a>
<a class="el" href="struct_system_1_1_collections_1_1_hash_set_1_1_enumerator.html">Enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#af7e1daad52bb15aefb5eff0f5d55f543">GetEnumerator</a> ()</td></tr>
<tr class="memdesc:af7e1daad52bb15aefb5eff0f5d55f543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is readonly. <br /></td></tr>
<tr class="separator:af7e1daad52bb15aefb5eff0f5d55f543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f1c680135bbafd8b8ba00cd7ba0e82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a82f1c680135bbafd8b8ba00cd7ba0e82">Add</a> (T item)</td></tr>
<tr class="memdesc:a82f1c680135bbafd8b8ba00cd7ba0e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add item to this <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a>.  <a href="class_system_1_1_collections_1_1_hash_set.html#a82f1c680135bbafd8b8ba00cd7ba0e82">More...</a><br /></td></tr>
<tr class="separator:a82f1c680135bbafd8b8ba00cd7ba0e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcd6ab3400eb06d805ec20b39714c5c"><td class="memItemLeft" align="right" valign="top"><a id="a7bcd6ab3400eb06d805ec20b39714c5c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryAdd</b> (T item, out T *entryPtr)</td></tr>
<tr class="separator:a7bcd6ab3400eb06d805ec20b39714c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ee9b8c0cefcf766f6aa4d703454519"><td class="memItemLeft" align="right" valign="top"><a id="a18ee9b8c0cefcf766f6aa4d703454519"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TryAddAlt&lt; TAltKey &gt;</b> (TAltKey item, out T *entryPtr)</td></tr>
<tr class="separator:a18ee9b8c0cefcf766f6aa4d703454519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5716d696814c48195730abbf46a5cfac"><td class="memItemLeft" align="right" valign="top"><a id="a5716d696814c48195730abbf46a5cfac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTo</b> (T[] array)</td></tr>
<tr class="separator:a5716d696814c48195730abbf46a5cfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583cfb9eb585dd1d1e9f1470a4e34c99"><td class="memItemLeft" align="right" valign="top"><a id="a583cfb9eb585dd1d1e9f1470a4e34c99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTo</b> (T[] array, int32 arrayIndex, int32 count)</td></tr>
<tr class="separator:a583cfb9eb585dd1d1e9f1470a4e34c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b75ac64b16d34e1a2f5193eeec21e25"><td class="memItemLeft" align="right" valign="top"><a id="a9b75ac64b16d34e1a2f5193eeec21e25"></a>
int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a9b75ac64b16d34e1a2f5193eeec21e25">RemoveWhere</a> (Predicate&lt; T &gt; match)</td></tr>
<tr class="memdesc:a9b75ac64b16d34e1a2f5193eeec21e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements that match specified predicate. Returns the number of elements removed. <br /></td></tr>
<tr class="separator:a9b75ac64b16d34e1a2f5193eeec21e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf817f471bd3e9eeaa92f5497166de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a4cdf817f471bd3e9eeaa92f5497166de">TrimExcess</a> ()</td></tr>
<tr class="memdesc:a4cdf817f471bd3e9eeaa92f5497166de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the capacity of this list to the size of the list (rounded up to nearest prime), unless count is 0, in which case we release references.  <a href="class_system_1_1_collections_1_1_hash_set.html#a4cdf817f471bd3e9eeaa92f5497166de">More...</a><br /></td></tr>
<tr class="separator:a4cdf817f471bd3e9eeaa92f5497166de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cc621da6e008f8864fa0c0a5a63c05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a24cc621da6e008f8864fa0c0a5a63c05">Add</a> (T value, out T *entryPtr)</td></tr>
<tr class="memdesc:a24cc621da6e008f8864fa0c0a5a63c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds value to <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a> if not contained already.  <a href="class_system_1_1_collections_1_1_hash_set.html#a24cc621da6e008f8864fa0c0a5a63c05">More...</a><br /></td></tr>
<tr class="separator:a24cc621da6e008f8864fa0c0a5a63c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e78a93f230f0504729637c5973d662f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a2e78a93f230f0504729637c5973d662f">AddAlt&lt; TAltKey &gt;</a> (TAltKey value, out T *entryPtr)</td></tr>
<tr class="memdesc:a2e78a93f230f0504729637c5973d662f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds value to <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a> if not contained already.  <a href="class_system_1_1_collections_1_1_hash_set.html#a2e78a93f230f0504729637c5973d662f">More...</a><br /></td></tr>
<tr class="separator:a2e78a93f230f0504729637c5973d662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7471e4d0fb29f60ba654ba7d345733f3"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a7471e4d0fb29f60ba654ba7d345733f3">GetHashKey</a> (int hashCode)</td></tr>
<tr class="memdesc:a7471e4d0fb29f60ba654ba7d345733f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_internal.html">Internal</a> method used for HashSetEqualityComparer.  <a href="class_system_1_1_collections_1_1_hash_set.html#a7471e4d0fb29f60ba654ba7d345733f3">More...</a><br /></td></tr>
<tr class="separator:a7471e4d0fb29f60ba654ba7d345733f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a852a1d5e73d6ffde8eb38c7e8e701e19"><td class="memItemLeft" align="right" valign="top"><a id="a852a1d5e73d6ffde8eb38c7e8e701e19"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_collections_1_1_hash_set.html#a852a1d5e73d6ffde8eb38c7e8e701e19">Count</a><code> [get]</code></td></tr>
<tr class="memdesc:a852a1d5e73d6ffde8eb38c7e8e701e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in this hashset. <br /></td></tr>
<tr class="separator:a852a1d5e73d6ffde8eb38c7e8e701e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2543033cfc63b1d70750777e3f64d59"><td class="memItemLeft" align="right" valign="top"><a id="ac2543033cfc63b1d70750777e3f64d59"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEmpty</b><code> [get]</code></td></tr>
<tr class="separator:ac2543033cfc63b1d70750777e3f64d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;, using a buckets array to map hash values to the Slots array. </p>
<p>Items in the Slots array that hash to the same value are chained together through the "next" indices.</p>
<p>The capacity is always prime; so during resizing, the capacity is chosen as the next prime greater than double the last capacity.</p>
<p>The underlying data structures are lazily initialized. Because of the observation that, in practice, hashtables tend to contain only a few elements, the initial capacity is set very small (3 elements) unless the ctor with a collection is used.</p>
<p>The +/- 1 modifications in methods that add, check for containment, etc allow us to distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to reset each bucket to -1 when resizing. See Contains, for example.</p>
<p>Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify this set.</p>
<p>Some operations can perform faster if we can assume "other" contains unique elements according to this equality comparer. The only times this is efficient to check is if other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we also have to check that the hashset is using the same equality comparer. If other has a different equality comparer, it will have unique elements according to its own equality comparer, but not necessarily according to ours. Therefore, to go these optimized routes we check that other is a hashset using the same equality comparer.</p>
<p>A <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a> with no elements has the properties of the empty set. (See IsSubset, etc. for special empty set checks.)</p>
<p>A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). If we didn't have these checks, we could be iterating over the set and modifying at the same time. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em><a class="el" href="interface_system_1_1_i_hashable.html">IHashable</a></em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a82f1c680135bbafd8b8ba00cd7ba0e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f1c680135bbafd8b8ba00cd7ba0e82">&#9670;&nbsp;</a></span>Add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add item to this <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a>. </p>
<p>Returns bool indicating whether item was added (won't be added if already present) </p><dl class="section return"><dt>Returns</dt><dd>true if added, false if already present </dd></dl>

</div>
</div>
<a id="a24cc621da6e008f8864fa0c0a5a63c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cc621da6e008f8864fa0c0a5a63c05">&#9670;&nbsp;</a></span>Add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out T *&#160;</td>
          <td class="paramname"><em>entryPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds value to <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a> if not contained already. </p>
<dl class="section return"><dt>Returns</dt><dd>true if added and false if already present </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to find </td></tr>
    <tr><td class="paramname">entryPtr</td><td>ponter to entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e78a93f230f0504729637c5973d662f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e78a93f230f0504729637c5973d662f">&#9670;&nbsp;</a></span>AddAlt&lt; TAltKey &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.AddAlt&lt; TAltKey &gt; </td>
          <td>(</td>
          <td class="paramtype">TAltKey&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out T *&#160;</td>
          <td class="paramname"><em>entryPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds value to <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a> if not contained already. </p>
<dl class="section return"><dt>Returns</dt><dd>true if added and false if already present </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to find </td></tr>
    <tr><td class="paramname">entryPtr</td><td>ponter to entry </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>TAltKey</em></td><td>&#160;:</td><td valign="top"><em>IHashable</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>bool</em></td><td>&#160;:</td><td valign="top"><em>operator</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>bool</em></td><td>&#160;:</td><td valign="top"><em>T</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>bool</em></td><td>&#160;:</td><td valign="top"><em>TAltKey</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a13717f7d3756f07db2c595dd62c08e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13717f7d3756f07db2c595dd62c08e51">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add item to this hashset. </p>
<p>This is the explicit implementation of the ICollection&lt;T&gt; interface. The other Add method returns bool indicating whether item was added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item to add</td></tr>
  </table>
  </dd>
</dl>
<p>Remove all items from this set. This clears the elements but not the underlying buckets and slots array. Follow this call by TrimExcess to release these. </p>

</div>
</div>
<a id="a507f17b20d92c5e771eff290c0f5c72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507f17b20d92c5e771eff290c0f5c72b">&#9670;&nbsp;</a></span>Contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.Contains </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this hashset contains the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item to check for containment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if item contained; false if not </dd></dl>

</div>
</div>
<a id="a407d3d4b0ca0ae486c39c06c237b3d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407d3d4b0ca0ae486c39c06c237b3d16">&#9670;&nbsp;</a></span>CopyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T[]&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy items in this hashset to array, starting at arrayIndex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>array to add items to </td></tr>
    <tr><td class="paramname">arrayIndex</td><td>index to start at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7860cbdba0a47d2c9cffb1a254cfcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7860cbdba0a47d2c9cffb1a254cfcf3">&#9670;&nbsp;</a></span>GetAndRemove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_system_1_1_result.html">Result</a>&lt;T&gt; <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.GetAndRemove </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove item from this container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>.Ok(value) if removed, with 'value' being the stored value; .Err if not (i.e. if the item wasn't in the <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a>) </dd></dl>

</div>
</div>
<a id="a976e1ccadf2eb15605fe3ac939690759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976e1ccadf2eb15605fe3ac939690759">&#9670;&nbsp;</a></span>GetAndRemoveAlt&lt; TAltKey &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_system_1_1_result.html">Result</a>&lt;T&gt; <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.GetAndRemoveAlt&lt; TAltKey &gt; </td>
          <td>(</td>
          <td class="paramtype">TAltKey&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove item from this container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>.Ok(value) if removed, with 'value' being the stored value; .Err if not (i.e. if the item wasn't in the <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a>) </dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>TAltKey</em></td><td>&#160;:</td><td valign="top"><em>IHashable</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>bool</em></td><td>&#160;:</td><td valign="top"><em>operator</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>bool</em></td><td>&#160;:</td><td valign="top"><em>T</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>bool</em></td><td>&#160;:</td><td valign="top"><em>TAltKey</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a7471e4d0fb29f60ba654ba7d345733f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7471e4d0fb29f60ba654ba7d345733f3">&#9670;&nbsp;</a></span>GetHashKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32 <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.GetHashKey </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hashCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_internal.html">Internal</a> method used for HashSetEqualityComparer. </p>
<p>Compares set1 and set2 according to specified comparer.</p>
<p>Because items are hashed according to a specific equality comparer, we have to resort to n^2 search if they're using different equality comparers. Checks if equality comparers are equal. This is used for algorithms that can speed up if it knows the other item has unique elements. I.e. if they're using different equality comparers, then uniqueness assumption between sets break. Workaround Comparers that throw ArgumentNullException for GetHashCode(null). </p><dl class="section return"><dt>Returns</dt><dd>hash codeInternalGetHashCode </dd></dl>

</div>
</div>
<a id="aa0992cfc11d299a4176d1fa6d44e3cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0992cfc11d299a4176d1fa6d44e3cd5">&#9670;&nbsp;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.Remove </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove item from this container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if removed; false if not (i.e. if the item wasn't in the <a class="el" href="class_system_1_1_collections_1_1_hash_set.html" title="Implementation notes: This uses an array-based implementation similar to Dictionary&lt;T&gt;,...">HashSet</a>) </dd></dl>

</div>
</div>
<a id="a4cdf817f471bd3e9eeaa92f5497166de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdf817f471bd3e9eeaa92f5497166de">&#9670;&nbsp;</a></span>TrimExcess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_collections_1_1_hash_set.html">System.Collections.HashSet</a>&lt; T &gt;.TrimExcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the capacity of this list to the size of the list (rounded up to nearest prime), unless count is 0, in which case we release references. </p>
<p>This method can be used to minimize a list's memory overhead once it is known that no new elements will be added to the list. To completely clear a list and release all memory referenced by the list, execute the following statements:</p>
<p>list.Clear(); list.TrimExcess(); <br  />
 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
